Структура канала 
```go
type hchan struct {
    qcount   uint           // сколько элементов сейчас в буфере
    dataqsiz uint           // размер буфера (0 для неблокирующего)
    buf      unsafe.Pointer // массив-буфер (ring buffer) или nil
    elemsize uint16         // размер одного элемента
    closed   uint32         // флаг закрытия
    elemtype *_type         // дескриптор типа элемента (для memmove, GC)
    sendx    uint           // индекс следующей записи в кольцевой буфер
    recvx    uint           // индекс следующего чтения из буфера
    recvq    waitq          // очередь ожидающих получателей (goroutine)
    sendq    waitq          // очередь ожидающих отправителей (goroutine)
    lock     mutex          // мьютекс канала
}

```
Очереди `sendq/recvq` — это двусвязные списки `sudog` (записи, указывающие на “уснувшие” горутины и их стековые слоты), которые рантайм паркует/будит.

То есть канал буквально паркует горутину и в дальнейшем её будит, если такого не случается, то возникает deadlock. 

**Как устроены операции**
### `send` (буферизированный пример)
1. `lock(&c.lock)`
2. Если есть ожидающий получатель в `recvq` → взять его, **скопировать элемент напрямую** в его слот, **разбудить**.
3. Иначе, если есть место в буфере → `memmove` в `buf[sendx]`, `sendx=(sendx+1)%dataqsiz`, `qcount++`.
4. Иначе (буфер полон) → поместить текущую горутину в `sendq` и `gopark`.
5. `unlock(&c.lock)`
### `recv`
1. `lock(&c.lock)`
2. Если есть ожидающий отправитель в `sendq` и канал небуферизованный → **рукопожатие** и пробуждение отправителя.
3. Иначе, если `qcount>0` → взять из `buf[recvx]`, `recvx=(recvx+1)%dataqsiz`, `qcount--`.
4. Иначе, если `closed` → вернуть zero-value, `ok=false`.
5. Иначе → поместить себя в `recvq` и `gopark`.
6. `unlock(&c.lock)`

**Что такое nil канал?**
Переменная типа `chan T` — это, по сути, **указатель на `hchan`**. 
```go
var ch chan int // ch == nil

```
**nil-указатель** вместо адреса на `hchan`. Никакого объекта канала на куче не существует: ни буфера, ни очередей, ни мьютекса — ничего.

### Отправка в nil-канал

Вход в `runtime.chansend(c *hchan, ...)`:
- Если `c == nil` и операция **блокирующая** (обычное `ch <- x` вне `select`), рантайм вызывает `gopark` и паркует горутину **навсегда**: раз “канала” нет, никто её не разбудит. В итоге, если все горутины уснут, планировщик зафиксирует _deadlock_ и паникнёт `fatal error: all goroutines are asleep - deadlock!`.
### Чтение из nil-канала
Аналогично в `runtime.chanrecv(c *hchan, ...)`:
- При `c == nil` и блокирующем пути — вечный `gopark` (ожидание навсегда).

При закрытии канала возникает паника:
```go
panic("close of nil channel")
```
