https://habr.com/ru/companies/avito/articles/774618/

Основная сущности внутри мапы для решения коллизии - **Бакеты**.

Бакеты - структура данных, в которых хранятся пары "ключ - значение" элементов.
По-началу их 8 штук. Внутри бакета хранятся 8 пар, когда бакет заполняется, инициализируется указатель на связанный бакет. Связанный список.

Мапа сама по себе структура с полями:
count - размер мапы. количество пар ключ-значение
B - log_2 количество бакетов. Для 8 бакетов B=3, для 16 B=4
noverflow - число переполненных бакетов
hash0 - сид хэша 
buckets - указатель на массив бакетов
oldbuckets - указатель на массив бакетов, из которых происходит эвакуация данных, когда бакетов становится больше. Является ячейкой памяти.
nevacuate - количество эвакуированных бакетов

У ключа считается хэш по хэш-функции (как правило значение uint64), далее для определения в какой бакет он направится берется остаток от деления по количеству бактов внутри мапы. Далее в вычисленный бакет записывается пара "ключ-значение". А если быть вернее то записывается младший бит для упрощения работы рантайма. В мапе хранится старший бит для определения в какую именно мапу писать ключ со значением

Эвакуция мапы происходит при load factor 6.5 (когда в среднем количество элементов в бакете становится равным 6.5). В таком случае мапа расширяется, а индексы пар перерасчитываются (перехэшируются).

В Go используются два подхода, которые сводятся к увеличению количества бакетов:

1. Увеличение общего количества бакетов и перераспределение пар по этим бакетам.
2. Создание бакета, на который даём ссылку в заполненный бакет. Если понадобится записать в заполненный, то мы запишем в тот, на который есть ссылка.

**Основная проблема**
Работа с процессором. Сравнивание ключей внутри бакета. Все работает на кэш-линиях. Чтобы все это сравнить - процессору нужно выполнить 8 операций, а так как всё происходит ассинхронно, то это еще более большие расходы.

![[Снимок экрана 2025-08-19 в 22.08.27.png]]
