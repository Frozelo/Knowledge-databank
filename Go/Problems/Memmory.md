### Блок A — Срезы, массивы, строки

**Задача 1 Реслайс и aliasing**

Вопросы: что выведет? где произойдёт (не)реаллокация? какие элементы шарятся?

```go
func main() {
    a := []int{1,2,3,4,5} // len = 5, cap = 5
    b := a[:3] // len = 3, cap = 5
    c := append(b, 9) // len = 4, cap = 5 // c = 1 2 3 9
    a[2] = 7 
    fmt.Println(a, b, c)

    // a = 1 2 7 9 5, b = 1 2 7, c = 1 2 7 9
}
```
_Ответ_:
- Шарится подлежащий массив (инициализируется при слайсинге а).
- Вывод: a = 1 2 7 9 5, b = 1 2 7, c = 1 2 7 9
- Реаллокаций нет, так как нет случаев, когда len превысил cap. Все слайсы ссылаются на единый массив

**Задача 2 append к самому себе**

Предскажите результат и объясните почему иногда он «ломается», если capacity другая.

```go
func main() {
    s := []int{1,2,3}
    s = append(s, s...)
    fmt.Println(s)
}
```

_Ответ_:
- Изначальный вывод: s = 1 2 3 1 2 3
- Почему может сломаться: **разобрать позднее**

**Задача 3 copy vs append**

Что будет в массивах? Какие элементы затираются и почему? Как работает copy?

```go
func main() {
    src := []int{1,2,3,4} 
    dst := src[:2] // 1 2 (sub slice for src slice) - shared head array
    copy(dst, src[2:]) - // copy src[2:] (3 4) into dst (1 2) -> dst = 3 4
    fmt.Println(src, dst) // head array is changed because of dst elements changes(indexes 0 1) -> src = 3 4 3 4
}
```
_Ответ_:
- Вывод: src = 3 4 3 4, dst = 3 4
- Затираем элементы внутри dst при копировании. Затираем 2 элемента, берем их из src (3 4). 0 1 -> 3 4
- Берет элементы из src, копирует минимальное возможное количество в dst. И наоборот dst из copy так же достает минимально возможное количество элементов. Грубо говоря копируется:
```go
n := min(len(dst)=2, len(src[2:])=2) = 2 элемента
```





