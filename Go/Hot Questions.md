## Hot Questions

> [!NOTE] Пометка
> Самые ходовые вопросы, которые часто мелькают на собеседованиях

### Arrays and Slices

1. Что такое слайс (slice) и массив (array)? Чем отличается массив от слайса?
	В Go **массивы** и срезы представляют собой структуры данных, состоящие из упорядоченных последовательностей элементов. Эти наборы данных очень удобно использовать, когда вам требуется работать с большим количеством связанных значений. Массив в Go представляет собой структуру данных, состоящую из упорядоченной последовательности элементов, емкость которой определяется в момент создания. После определения размера массива его нельзя изменить.
	
	Срез — это версия массива с переменной длиной, дающая разработчикам дополнительную гибкость использования этих структур данных. 
	Срезы — это то, что обычно называют массивами в других языках. Срез — это тип данных Go, представляющий собой мутируемую или изменяемую упорядоченную последовательность элементов. Поскольку размер срезов не постоянный, а переменный, его использование сопряжено с дополнительной гибкостью. При работе с наборами данных, которые в будущем могут увеличиваться или уменьшаться, использование среза обеспечит отсутствие ошибок при попытке изменения размера набора. В большинстве случаев возможность изменения стоит издержек перераспределения памяти, которое иногда требуется для срезов, в отличие от массивов.

```go
// Создадим срез, содержащий элементы строкового типа данных:
seaCreatures := []string{"shark", "cuttlefish", "squid", "mantis shrimp", "anemone"} // len: 5, cap: 5

// Если вы хотите создать срез определенной длины без заполнения элементов коллекции, 
// вы можете использовать встроенную функцию make()
oceans := make([]string, 3) // output: [ "" "" "" ], len: 3, cap: 3

// Если вы хотите заранее выделить определенный объем памяти, вы можете использовать в команде make() третий аргумент:
oceans := make([]string, 3, 5) // output: [ "" "" "" ], len: 3, cap: 5
```

2. Как устроен слайс в Go? Как устроен массив в Go?
Слайс под капотом - структура с указателем на адрес базового массива и также две переменные: len и cap. 
   Len - Длина слайса - количество элементов, которое находится внутри слайса.
   Cap - Ёмкость слайса - количество элементов, которые мы можем поместить внутрь слайса сверх len без его дальнейшего расширения. 
```go
   type slice struct {
	   array unsafe.Pointer
	   len   int
	   cap int
   }
```
   Массив - последовательно выделенная область памяти. Частью массива является его неизменяемая длина. 

3. Как можно создать слайс? Что такое zero-value и какое оно у слайса?
Основные виды объявления слайса:
```go
   var slice []int             //declare nil slice len - 0, cap - 0
   var slice = []int{1, 2, 3}  //init slice len - 3, cap - 3
   slice := []int{1, 2, 3}     //init slice len - 3, cap - 3
   slice := make([]int, 0, 3)  //init слайс через make len - 0, cap - 10
   slice := make([]int, 3)     //init слайс через make len - 3, cap - 3 
```
  Zero-value для слайса - это nil, а len и cap равны нулю, так как "под ним" нет инициализированного массива:
```go
var a []int

fmt.Prinln((a == nil, len(a), cap(a)) // output: true 0 0
a = append(a, 1)
fmt.Println(a == nil, len(a), cap(a)) // output: false 1 1
```

4. Что такое nil слайс и чем отличается? Можно ли добавлять элементы в nil слайс?
Все основные операции, совершаемые над обычным (инициализированным) слайсом применимы и к nil слайсам
```go
var slice []int

fmt.Println(len(slice), cap(slice)) //output 0 0

slice = append(slice, 10)

fmt.Println(slice, len(slice), cap(slice)) // output [ 10 ] 1 1
```
   
5. Как проверить слайс на пустоту?
Проверить его длину на ноль
```go
var a []int

// не правильно
fmt.Println(a == nil) // true

// а если так
a := []int{}
fmt.Println(a == nil) // false

// поэтому правильно так
fmt.Println(len(a) == 0) // true
```

6. Как работает базовая функция append для слайсов? Можно ли применить к массивам? Напишите свою функцию append.
Функция принимает на вход слайс и переменное количество элементов для добавления в слайс. Append расширяет слайс за пределы его len, возвращая при этом новый слайс.
   
   Если количество элементов, которые мы добавляем в слайс, не будет превышать cap, вернется новый слайс, который ссылается на тот же базовый массив, что и предыдущий слайс. Если количество добавляемых элементов превысит cap, то вернется новый слайс, базовым для которого будет новый массив.
   
```go
// создаем слайс с capacity равным 3 и длиной 0
slice := make([]int, 0, 3) 	// len: 0, cap: 3
	
// далее заполняем слайс тремя элементами
slice = append(slice, 1) 	// len: 1, cap: 3
slice = append(slice, 2, 3) 	// len: 3, cap: 3

// получаем ожидаемый результат
fmt.Println(slice) // output [ 1, 2, 3 ]

// окей, теперь попробуем присводить слайс другому слайсу
// помним то, что слайс является структурой из трех элементов len, cap и указателем н первый элемент массива
// поэтому в sliceCopy мы получаем скопированные значение len и cap, а так же указатель на тот же массив, что и у переменной slice
sliceCopy := slice

// пробуем менять первый элемент в новом слайсе
sliceCopy[1] = 10
	
// убеждаемся, что в обоих слайсах изменились значения, все из-за базового массива
fmt.Println(slice, sliceCopy) // output: slice: [ 1, 10, 3 ] sliceCopy: [ 1, 10, 3 ]

// хорошо, теперь пробуем добавить новый элемент в первый слайс
slice = append(slice, 4)
// тут у нас функция append "видит", что мест больше нет и увеличивает cap в двое, увеличивает len на один
// и создает новый базовый массив с местимостью в 6 элементов, что и видим на печати
fmt.Println(slice) // output: [ 1, 10, 3, 4] len: 4, cap: 6
// но что случилось тут? ничего, просто ничего, теперь первая переменная смотрит на другой базовый массив и они больше никак не связаны
fmt.Println(sliceCopy) // output: [ 1, 2, 3 ] len: 3, cap: 3

// точно не связаны? ну давай убедимся! пробуем менять значения первых элементов в обоих слайсах
sliceCopy[0] = 50
slice[0] = 80

fmt.Println(slice, sliceCopy) // output: slice: [ 80, 10, 3, 4 ] sliceCopy: [ 50, 10, 3 ]
```

   С масивами функцию append использовать нельзя иначе получим ошибку: `first argument to append must be slice; have T`
   Реализация простой добавки в слайс
```go
func main() {
	fmt.Println(Append([]int{1, 2, 3}, 4))
}

func Append[T any](dst []T, el T) []T {
	var res []T

	resLen := len(dst) + 1
	if resLen <= cap(dst) {
		res = dst[:resLen]
	} else {
		resCap := resLen
		if resCap < 2*len(dst) {
			resCap = 2 * len(dst)
		}

		res = make([]T, resLen, resCap)
		copy(res, dst)
	}

	res[len(dst)] = el
	return res
}
   
```
   
7. Как можно добавить элементы в слайс? Что будет если элемент не вмещается в размер слайса?
   Использование append
```go
slice := make([]int, 0, 10) // len: 0, cap: 10
for i := 0; i < 10; i++ {
	slice = append(slice, i*2)
}
   
```
   
   Индексы
```go
slice := make([]int, 10) // len: 10, cap: 10
for i := 0; i < 10; i++ {
	slice[i] = i*2
}
```

   Проблема в том, что во втором случае если количество элементов, которые мы хотим добавить в слайс превысит емкость исходного слайса, тогда мы получим панику: `panic: runtime error: index out of range [10] with length 10`
```go
slice := make([]int, 10) // len: 10, cap: 10
for i := 0; i <= 10; i++ {
	slice[i] = i * 2
}
```
   При append произойдет аллокакция памяти для базового массива, слайс расширится. 
   
8. Как можно скопировать слайс? Что такое функция copy? Как добиться аналогичного поведения copy с помощью append?
Работаем с функцией copy сигнатура
```go
func copy(dst, src []Type) int
```

9. Как можно слить два слайса?
Объединение фрагментов в Go легко достигается с помощью той же встроенной функции append. Как мы помним он принимает срез (s1) в качестве первого аргумента и все элементы из второго среза (s2) в качестве второго. Возвращается обновленный срез со всеми элементами из s1 и, который может быть присвоен другой переменной.

```go
s1 := []int{1, 2, 3}
s2 := []int{4, 5, 6}

s3 := append(s1, s2...)
fmt.Println(s3) // output: [ 1, 2, 3, 4, 5, 6 ]
```

10. Как можно нарезать слайс? Какие есть нюансы, подводные камни?
Можно сделать подсалайс из слайса или массива:
```go
slice := []int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}
subSlice := slice[3:8] // [ 4, 5, 6, 7, 8 ]
```

Нюанс в том, что если мы изменим или добавим значение в сабслайс, то это значение изменится/добавится и в базовый слайс

```go
subSlice[0] = 101

fmt.Println(slice) // [1 2 3 101 5 6 7 8 9 10]
fmt.Println(subSlice) // [101 5 6 7 8]
```

Видим, что в базовом слайсе тоже поменялись значения, а все потому, что у под слайса все тот же базовый массив, а для подслайса нулевой элемент это элемент под индексом 3 в базовом. Примерно такое же поведение наблюдается у функции append, если его применить к под слайсу базового слайса:
```go
slice := make([]int, 10, 25)
subSlice := slice[3:5] // [ 0, 0]

fmt.Println(len(slice), cap(slice)) // 10 25
fmt.Println(len(subSlice), cap(subSlice)) // 2 22

subSlice = append(subSlice, 11)

fmt.Println(slice) // [0 0 0 0 0 11 0 0 0 0]
fmt.Println(subSlice) // [0 0 11]
```
причина данного поведения в том, что у обоих слайсов один базовый массив, а так же у под слайса своя "копия" слайса с полями len и cap и когда мы пытаемся добавить в дочерний слайс элемент, при условии, что в родитльском хватает емкости, мы просто перезаписываем значение в базовом массива.

---
### Maps

1. Что такое Map? Как устроен в Go? Желательно приблизительно понимать структуру (type hmap struct) и его поля
   Map - структура данных, ассоциативный массив или хэш-таблицу типа ключ-значение. Он позволяет хранить пары "ключ-значение", где каждый ключ уникален, и используется для быстрого доступа к значениям по ключам.
   **Основные понятия**:
   - Хэш-функция 
   - Бакет
   - Коллизия

```go
// Header for a Go map
type hmap struct {
	count      int    // размер мапы. используется функцией len()
	flags      uint8 
	B          uint8  // log_2 количество бакетов. Для 8 бакетов B=3, для 16 B=4 
	noverflow  uint16 // примерное число переполненных бакетов
	hash0      uint32 // seed для хэша. всегда задаётся и генерируется при создании мапы
	
	buckets    usafe.Pointer  // указатель на массив 2^B бакетов; nil eсли count=0
	oldbuckets unsafe.Pointer // указатель на массив предыдущих бакетов. для эвакуации 
	nevacuate  uintptr        // количество "эвакуированых" бакетов
	
	extra      *mapextra      // опциональные поля
}

// Bucket for a Go map
type bmap struct {
	tophash [bucketCnt]uint8  // массив tophash
	// После массива tophash идет массив размера bucketCnt ключей и массив размера bucketCnt элементов
}
```
   
2. Что такое хеш-функция?
   Под ней понимают функцию, которая принимает значение (ключ) неопределенного размера и возвращает значение фиксированной длины. В случае c Go она возвращает `uint64`. Одно из главных свойств - стабильность. Для одного и того же переданного значения она должна возвращать один и тот же результат;
   **Основные характеристики хеш-функций**:
   - Фиксированный размер выходных данных: Независимо от размера входных данных, хеш-функция всегда возвращает значение фиксированной длины. Например, хеш-функция SHA-256 всегда возвращает 256 бит (32 байта).
   - Детерминированность: Для одного и того же входного значения хеш-функция всегда будет возвращать одно и то же хеш-значение. 
   - Быстрота вычисления: Хеш-функции должны быть достаточно быстрыми для вычисления, чтобы их можно было использовать в реальном времени.
   - Устойчивость к коллизиям: Хорошая хеш-функция должна минимизировать вероятность коллизий, то есть ситуации, когда два разных входных значения дают одинаковый хеш. Хотя коллизии возможны (особенно для хеш-функций с фиксированным размером), хорошая хеш-функция делает их редкими.
   - Односторонность: Для криптографических хеш-функций важно, чтобы было невозможно восстановить исходные данные из хеш-значения. Это свойство называется односторонностью.
3. Почему нельзя брать адрес на значение, хранящееся по ключу в map?
   - Нельзя получить адрес элемента. Потому что при росте мапы оно переедет в другой бакет и адрес у него, соответственно, поменяется;
     
4. Что такое эвакуация, и в каком случае она будет происходить?
   Рост мапы начинается в двух случаях:   
   - Бакеты в среднем заполнены на больше чем 80%. В таком случае количество бакетов увеличивается примерно вдвое
   - Второй (частный) случай разобрать позднее
   
   Сам алгоритм несложный (практически) - проходим по все элементам в бакете, выбираем новый бакет и переносим ключ (рехешируем), значение и топхеш.  
   При росте мапы количество бакетов увеличивается вдвое. Если разделить слайс новых бакетов на две половины, то для каждого элемента внутри старого бакета есть два пути ~~this is the way~~ - либо в первую половину либо во вторую. А если считать каждую половину новых бакетов _отдельным_ слайсом, то можно сказать что в пределах такой половины индекс бакета для элемента не поменяется.
   
> [!NOTE] Пример
> Было 8 бакетов, мы начали рост, количество бакетов удвоилось и стало 16. В таком случае каждый элемент бакета по индексу 3(четвертый бакет) перенесется либо в бакет в первой половине по индексу 3, либо во второй по индексу 11 (3+8). Соответственно последний бакет с индексом 7 переносится либо в 7ой либо в 15й(7+8).


5. Какие есть особенности синтаксиса получения и записи значений в map?   
6. Как происходит поиск по ключу в map?
	Осуществляется с использованием хэш-таблицы, что позволяет выполнять операции поиска, вставки и удаления с высокой эффективностью.
   - Применение хэш-функцию к ключу. Преобразуется ключ в хэш-значение, которое представляет собой целое число
   - Определение индекса в ведра. Индекс вычисляется с использованием операции взятия по модулю от размера массива ведер.
   - Поиск в ведре. Каждое ведро может содержать несколько пар "ключ-значение", особенно в случае коллизий (когда два разных ключа имеют одинаковое хэш-значение). Ведра могут реализовываться как связанные списки или другие структуры данных. Если ведро пустое - ключ не существует в map и возвращает exists false и нулевое значение. Если ведро содержит элементы, Go перебирает пары "ключ-значение" в этом ведре и сравнивает ключи с искомым ключом. Если ключ найден, возвращается соответствующее значение. 
8. Каков порядок перебора map?

   Порядок итерации не сохраняется. При каждой новой итерации мапы последовательность возвращаемых элементов может отличаться. Под капотом каждый раз выбирается рандомный бакет, с которого начинается итерация. Для сохранения нужного порядка придется сохранять ключи в отдельном массиве и итерироваться по нему;
10. Что будет происходить при конкуррентной записи в map? Как можно решить эту проблему?
   
    В Go встроенный тип данных `map` не является потокобезопасным (concurrency-safe). Это означает, что если несколько горутин одновременно обращаются к одной и той же карте **и** хотя бы одна из них пытается вносить изменения (добавлять, удалять или обновлять элементы), то возникнет состояние гонки. В лучшем случае Go-рантайм выбросит panic вида «concurrent map read and map write» или «concurrent map writes», а в худшем — произойдут более сложные ошибки, связанные с порчей данных.
   - Внутренняя реализация map в Go не предназначена для конкурентных изменений без дополнительной синхронизации.
   - Любые операции записи (вставка, удаление, обновление) могут менять внутренние структуры (хэш-таблицы), что приводит к неконсистентным данным, если несколько горутин модифицируют их одновременно.
    **Как решить проблему?**
    - sync Mutex, sync.RWMutex - примитив синхронизации. Обращение к полю `m` напрямую должно быть закрыто для внешнего кода. Все операции выполняются только через методы, защищённые мьютексом.
    - sync.Map - Начиная с Go 1.9 в стандартной библиотеке есть тип `sync.Map`, специально предназначенный для потокобезопасного хранения данных. Он реализует свои внутренние механизмы синхронизации и подходит для высокопараллельных сценариев, где ключи и значения могут часто меняться. Однако `sync.Map` имеет свои особенности и не всегда даёт выигрыш:
      Он оптимизирован для сценариев «write-once, read-many» — часто чтения и редко записи.
    - В некоторых случаях можно выстроить доступ к карте через отдельную горутину, которая «владеет» структурой данных, а все операции выполняются по каналам (channel). Так достигается модель «актора»: чтения и записи производятся последовательно внутри одного потока. Это упрощает логику, но требует дополнительного кода для маршрутизации операций.
---
### Channels

1. Что такое канал? Чем отличается буферизированный канал от небуферизированного?

Канал — это механизм в Go для безопасной передачи данных между горутинами.
Отличия:

Небуферизированный канал (make(chan T)):
Отправка блокирует отправителя, пока получатель не готов принять данные (и наоборот). Синхронная передача.
Буферизированный канал (make(chan T, N)):
Отправка блокируется только при заполнении буфера (ёмкости N), а чтение — при пустом буфере. Асинхронная передача.

2. Как создать канал? Как закрыть канал?

```go
chUnbuffered := make(chan int)    // Небуферизированный
chBuffered := make(chan int, 10)  // Буферизированный
```

```go
close(chBuffered)  // Закрывает канал (выполняется отправителем)
```
3. Как читать из канала и писать в канал?

Запись: ch <- 42
(блокирует, пока данные не будут получены или пока есть место в буфере).
Чтение: value := <-ch или value, ok := <-ch (если ok == false, канал закрыт).

4. Зачем нужны в целом каналы?

- Синхронизация горутин.
- Безопасная передача данных без гонок (race conditions).
- Реализация паттернов: producer-consumer, worker pools и т.д.

5. Что будет, если читать из закрытого канала?

Когда канал закрыт (с помощью встроенной функции close(ch)), дальнейшие операции чтения (получения значений) из него дают нулевое (zero) значение типа и признак, что канал закрыт. В Go обычно чтение из канала оформляют так:

```go
v, ok := <-ch
```
v — это значение, считанное из канала (при закрытом канале это будет zero value);
ok — булево значение, которое при закрытом канале будет false.

При этом чтение из закрытого канала не вызывает панику и не блокируется: если канал закрыт и данных в буфере нет, возвращается zero value и ok == false.

6. Что будет, если писать в закрытый канал?

Вызывает панику 

7. Что будет если закрыть закрытый канал?

Вызывает панику 

8. Что такое nil канал и что будет если писать и читать от туда?


Nil канал - неинициализированный канал, который никуда не указывает. Если попытаться сделать send (операция записи) или receive (операция чтения) из такого канала, то соответствующая горутина будет блокироваться навсегда. Причём никакой ошибки на уровне компиляции или рантайма при этом не возникает — просто программа «зависает» на такой операции.

---
### Strings

1. Что из себя представляет тип данных string в языке Golang? Можно ли изменить определенный символ в строке? Что происходит при склеивании строк?

Строки же представляют собой _неизменяемый_ последовательный набор байт _фиксированного размера_. Это означает, что вы не можете изменять строки — только создавать новые. Это важно понимать в контексте производительности программы. В программах, где нужна очень высокая производительность, постоянное создание большого количества строк создаст ощутимую нагрузку на сборщик мусора.
   
   При склеивании строк в Go создается новая строка, которая содержит объединенное содержимое. Вы можете использовать оператор `+` для склеивания строк:
   
   При каждом склеивании строк создается новая строка, и если вы часто выполняете операции склеивания, это может привести к неэффективному использованию памяти (см выше). В таких случаях рекомендуется использовать `strings.Builder`, который оптимизирован для построения строк:
   
```go
package main

import (
	"fmt"
	"strings"
)

func main() {
	var builder strings.Builder
	builder.WriteString("Hello, ")
	builder.WriteString("world!")
	result := builder.String()
	fmt.Println(result)
}

```

2. Как можно оперировать строками?
  -  Конвертация (в срез байтов, срез рун)
  -  Функции пакета strings
  - Работа с regexp
  -  Конкатенация 
	  - + - В большинстве случаев такого подхода достаточно (Go оптимизирует конкатенацию при компиляции, если строковые литералы).
	  - fmt.Sprintf - Cоздание строки с форматированием
	  - string.Builder - Эффективная по памяти и времени сборка строки в циклах
3. Что будет если сложить строки?

Новая строка из сложенных двух. При каждом сложении создаётся новый объект типа `string`. Если внутри цикла многократно использовать `s = s + something`, то на каждом шаге будет происходить дополнительная аллокация памяти, что может приводить к существенным накладным расходам.
4. Как определить количество символов для строки?

Нужно понимать, что при функции *len* возвращается количество байтов в строке, а не число символов. Строки в Go хранятся в UTF-8 
   Чтобы получить именно **количество символов** (количество рун), есть два основных способа:
   - **Сконвертировать строку в срез рун** и измерить его длину:
   - **Использовать пакет `unicode/utf8`** и функцию `utf8.RuneCountInString`:
```go
import "unicode/utf8"

s := "Привет"
fmt.Println(utf8.RuneCountInString(s)) // 6
```
```go
s := "Привет"              // 6 символов
r := []rune(s)
fmt.Println(len(r))        // 6
```
 
5. Какие есть нюансы при итерации по строке?

Итерация «по рунам» (через `for range`)
   Итерация по байтам в обычном for
```go
s := "Привет"
for i, r := range s {
    fmt.Printf("Byte index: %d, rune: %c\n", i, r)
}

```
```go
s := "Привет"
for i := 0; i < len(s); i++ {
    fmt.Printf("Index %d: byte = %x\n", i, s[i])
}

```
	
6. Как эффективно склеивать строки (конкатенация строк)?
   - **`+`** и **`fmt.Sprintf`**: когда конкатенации немного (пара строк) или нужно форматирование.
   - **`strings.Builder`** (или `bytes.Buffer`) для многократных, последовательных операций, особенно в цикле. Это наиболее эффективный способ.
   - **`strings.Join`** для быстрого объединения готового среза строк через разделитель.
---
### Types

1. Какие бывают типы в Go? Целочисленные, дробные, комплексные, структуы, интерфесы, время и дополнить.
2. Отличие uint от int?
3. Что такое обычный int и какие есть нюансы его реализации?
4. Как преобразовать строку в int и наоборот? Можно ли сделать int(string) и string(int) соответственно?
5. Сколько в памяти занимают реализации int32 и int64?
6. Какие предельные значения int32 и int64?
7. Какой результат получим если разделить int на 0 и float на 0?
8. Что такое константы и можно ли их изменять?
9. Что такое iota?
10. Что такое структура (stuct) в Go? Зачем они нужны?
11. Что такое метод? Как они выглядят?
12. Как осуществляется наследование в Go?
13. Что такое тип rune? Зачем их использовать?
14. Что такое тип byte?
15. Что такое goto?
16. Какие циклы есть в Go?
---
### Interfaces

1. Что такое интерфейсы в Go? Чем отличается от интерфейсов в дпугих языказ, например, Java, PHP. Что такое утиная типизация?
2. Внутренее устройство интерфейса, какое оно (структура iface, itab)?
3. Сделать интерфейс для вычисления площади круга и квадрата, реализовать их в структурах cicle и square.
4. Что такое пустой интерфейс?
5. Что такое nil интерфейс?
6. Что такое type switch?
7. Как определить тип интерфейса?
8. Как преобразовать интерфейс к другому типу?
9. Где следует поместить описание интерфейса: в пакете с реализацией или в пакете, где этот интерфейс используется? Почему?
---
### Runtime Go

1. Что такое runtime (планировщик sheduler)? Как он устроен в Go?

Runtime Go - среда выполнения Go кода.
Сотоит из:
- Scheduler - отвечает за управление горутинами и распределение их на систмемные потоки.
- GC
- Syscalls

Scheduler основан на M:N (потоки:горутины) модели, где:
- **G**oroutine - отдельная горутина, сущность легковесных потоков в Go (что исполняем)
- **M**achine - Системный поток ОС (где исполняем)
- **P**rocessor - Логический процессор планировщика Go (очередь горутин)

**Как связаны GMP**
Горутины (G) планируются и исполняются через планировщик (P)
M поднимают P и исполняют горутины из очереди P
Число P по умолчанию соответствует GOMAXPROCS. Если 8 ядер, обычно Go сам выставляет GOMAXPROCS=8, значит будет 8 P.

2. Что такое Gorutine (горутина)?
3. В чем отличие горутины от потока?
4. Как устроены горутины, сколько памяти они занимают в стеке?
5. Кто управляет горутинами? Какой тип многозадачности используется в Go и какой был до версии Go 1.15?
6. Что такое GC (garbadge collector/сборщик мусора)?
7. Как работает сборщик мусора в Go?
8. Как проверить тип переменной в среде выполнения?
---
### Testing

1. Что такое runtime (планировщик sheduler)? Как он устроен в Go?
2. Что такое Gorutine (горутина)?
3. В чем отличие горутины от потока?
4. Как устроены горутины, сколько памяти они занимают в стеке?
5. Кто управляет горутинами? Какой тип многозадачности используется в Go и какой был до версии Go 1.15?
6. Что такое GC (garbadge collector/сборщик мусора)?
7. Как работает сборщик мусора в Go?
8. Как проверить тип переменной в среде выполнения?
---
### CI/CD

0. Что такое CI/CD?
1. Что такое линтеры (linters) зачем они нужны и как их использовать?
2. Как можно измерить использование памяти в Go? Что такое pprof?
3. Что такое Prometheus и Grafana? Зачем они нужны?
---
### Other

1. Зачем используется ключевое слово defer в Go?
2. Каков порядок возврата при использовании несколько функций с defer в рамках одной внешней функции?
3. Как передаются значения в функции, перед которыми указано ключевое слово defer? Пример:

```go
func main() {
	nums := 1 << 5 // 32

	defer fmt.Println(nums) // тут как?

	nums = nums >> 1 //16

	fmt.Println("done")
}
```

4. Какие бывают способоы синхронизации данных в Go? (про каналы тоже не забываем)
5. Что такое mutex, какие они бывают и как их использовать?
6. Что такое atomics, какие бывают и как и когда их лучше использовать?
7. Что такое sync.Map?
8. Что такое lock-free структуры данных, и есть ли в Go такие?
9. Как можно обработать панику с помощью defer и recovery?
10. Что такое context в Go? Какие бывают context в Go? Когда их нужно использовать и зачем?
11. Что такое указатели? Как передаются параметры в функцию по указателю или по значению? Какие типы неявно передаются как указатель? Как передать по указателю?
12. Что такое пакеты (package) в Go? Как их создавать и импортировать?
13. Можно ли реализовать sync.Mutex и sync.WaitGroup на каналах? Как?
