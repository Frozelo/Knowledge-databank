T## Hot Questions

> [!NOTE] Пометка
> Самые ходовые вопросы, которые часто мелькают на собеседованиях

### Arrays and Slices

1. Что такое слайс (slice) и массив (array)? Чем отличается массив от слайса?
	В Go **массивы** и срезы представляют собой структуры данных, состоящие из упорядоченных последовательностей элементов. Эти наборы данных очень удобно использовать, когда вам требуется работать с большим количеством связанных значений. Массив в Go представляет собой структуру данных, состоящую из упорядоченной последовательности элементов, емкость которой определяется в момент создания. После определения размера массива его нельзя изменить.
	
	Срез — это версия массива с переменной длиной, дающая разработчикам дополнительную гибкость использования этих структур данных. 
	Срезы — это то, что обычно называют массивами в других языках. Срез — это тип данных Go, представляющий собой мутируемую или изменяемую упорядоченную последовательность элементов. Поскольку размер срезов не постоянный, а переменный, его использование сопряжено с дополнительной гибкостью. При работе с наборами данных, которые в будущем могут увеличиваться или уменьшаться, использование среза обеспечит отсутствие ошибок при попытке изменения размера набора. В большинстве случаев возможность изменения стоит издержек перераспределения памяти, которое иногда требуется для срезов, в отличие от массивов.

```go
// Создадим срез, содержащий элементы строкового типа данных:
seaCreatures := []string{"shark", "cuttlefish", "squid", "mantis shrimp", "anemone"} // len: 5, cap: 5

// Если вы хотите создать срез определенной длины без заполнения элементов коллекции, 
// вы можете использовать встроенную функцию make()
oceans := make([]string, 3) // output: [ "" "" "" ], len: 3, cap: 3

// Если вы хотите заранее выделить определенный объем памяти, вы можете использовать в команде make() третий аргумент:
oceans := make([]string, 3, 5) // output: [ "" "" "" ], len: 3, cap: 5
```

2. Как устроен слайс в Go? Как устроен массив в Go?
Слайс под капотом - структура с указателем на адрес базового массива и также две переменные: len и cap. 
   Len - Длина слайса - количество элементов, которое находится внутри слайса.
   Cap - Ёмкость слайса - количество элементов, которые мы можем поместить внутрь слайса сверх len без его дальнейшего расширения. 
```go
   type slice struct {
	   array unsafe.Pointer
	   len   int
	   cap int
   }
```
   Массив - последовательно выделенная область памяти. Частью массива является его неизменяемая длина. 

3. Как можно создать слайс? Что такое zero-value и какое оно у слайса?
Основные виды объявления слайса:
```go
   var slice []int             //declare nil slice len - 0, cap - 0
   var slice = []int{1, 2, 3}  //init slice len - 3, cap - 3
   slice := []int{1, 2, 3}     //init slice len - 3, cap - 3
   slice := make([]int, 0, 3)  //init слайс через make len - 0, cap - 10
   slice := make([]int, 3)     //init слайс через make len - 3, cap - 3 
```
  Zero-value для слайса - это nil, а len и cap равны нулю, так как "под ним" нет инициализированного массива:
```go
var a []int

fmt.Prinln((a == nil, len(a), cap(a)) // output: true 0 0
a = append(a, 1)
fmt.Println(a == nil, len(a), cap(a)) // output: false 1 1
```

4. Что такое nil слайс и чем отличается? Можно ли добавлять элементы в nil слайс?
Все основные операции, совершаемые над обычным (инициализированным) слайсом применимы и к nil слайсам
```go
var slice []int

fmt.Println(len(slice), cap(slice)) //output 0 0

slice = append(slice, 10)

fmt.Println(slice, len(slice), cap(slice)) // output [ 10 ] 1 1
```
   
5. Как проверить слайс на пустоту?
Проверить его длину на ноль
```go
var a []int

// не правильно
fmt.Println(a == nil) // true

// а если так
a := []int{}
fmt.Println(a == nil) // false

// поэтому правильно так
fmt.Println(len(a) == 0) // true
```

6. Как работает базовая функция append для слайсов? Можно ли применить к массивам? Напишите свою функцию append.
Функция принимает на вход слайс и переменное количество элементов для добавления в слайс. Append расширяет слайс за пределы его len, возвращая при этом новый слайс.
   
   Если количество элементов, которые мы добавляем в слайс, не будет превышать cap, вернется новый слайс, который ссылается на тот же базовый массив, что и предыдущий слайс. Если количество добавляемых элементов превысит cap, то вернется новый слайс, базовым для которого будет новый массив.
   
```go
// создаем слайс с capacity равным 3 и длиной 0
slice := make([]int, 0, 3) 	// len: 0, cap: 3
	
// далее заполняем слайс тремя элементами
slice = append(slice, 1) 	// len: 1, cap: 3
slice = append(slice, 2, 3) 	// len: 3, cap: 3

// получаем ожидаемый результат
fmt.Println(slice) // output [ 1, 2, 3 ]

// окей, теперь попробуем присводить слайс другому слайсу
// помним то, что слайс является структурой из трех элементов len, cap и указателем н первый элемент массива
// поэтому в sliceCopy мы получаем скопированные значение len и cap, а так же указатель на тот же массив, что и у переменной slice
sliceCopy := slice

// пробуем менять первый элемент в новом слайсе
sliceCopy[1] = 10
	
// убеждаемся, что в обоих слайсах изменились значения, все из-за базового массива
fmt.Println(slice, sliceCopy) // output: slice: [ 1, 10, 3 ] sliceCopy: [ 1, 10, 3 ]

// хорошо, теперь пробуем добавить новый элемент в первый слайс
slice = append(slice, 4)
// тут у нас функция append "видит", что мест больше нет и увеличивает cap в двое, увеличивает len на один
// и создает новый базовый массив с местимостью в 6 элементов, что и видим на печати
fmt.Println(slice) // output: [ 1, 10, 3, 4] len: 4, cap: 6
// но что случилось тут? ничего, просто ничего, теперь первая переменная смотрит на другой базовый массив и они больше никак не связаны
fmt.Println(sliceCopy) // output: [ 1, 2, 3 ] len: 3, cap: 3

// точно не связаны? ну давай убедимся! пробуем менять значения первых элементов в обоих слайсах
sliceCopy[0] = 50
slice[0] = 80

fmt.Println(slice, sliceCopy) // output: slice: [ 80, 10, 3, 4 ] sliceCopy: [ 50, 10, 3 ]
```

   С масивами функцию append использовать нельзя иначе получим ошибку: `first argument to append must be slice; have T`
   Реализация простой добавки в слайс
```go
func main() {
	fmt.Println(Append([]int{1, 2, 3}, 4))
}

func Append[T any](dst []T, el T) []T {
	var res []T

	resLen := len(dst) + 1
	if resLen <= cap(dst) {
		res = dst[:resLen]
	} else {
		resCap := resLen
		if resCap < 2*len(dst) {
			resCap = 2 * len(dst)
		}

		res = make([]T, resLen, resCap)
		copy(res, dst)
	}

	res[len(dst)] = el
	return res
}
   
```
   
7. Как можно добавить элементы в слайс? Что будет если элемент не вмещается в размер слайса?
   Использование append
```go
slice := make([]int, 0, 10) // len: 0, cap: 10
for i := 0; i < 10; i++ {
	slice = append(slice, i*2)
}
   
```
   
   Индексы
```go
slice := make([]int, 10) // len: 10, cap: 10
for i := 0; i < 10; i++ {
	slice[i] = i*2
}
```

   Проблема в том, что во втором случае если количество элементов, которые мы хотим добавить в слайс превысит емкость исходного слайса, тогда мы получим панику: `panic: runtime error: index out of range [10] with length 10`
```go
slice := make([]int, 10) // len: 10, cap: 10
for i := 0; i <= 10; i++ {
	slice[i] = i * 2
}
```
   При append произойдет аллокакция памяти для базового массива, слайс расширится. 
   
8. Как можно скопировать слайс? Что такое функция copy? Как добиться аналогичного поведения copy с помощью append?
Работаем с функцией copy сигнатура
```go
func copy(dst, src []Type) int
```

9. Как можно слить два слайса?
Объединение фрагментов в Go легко достигается с помощью той же встроенной функции append. Как мы помним он принимает срез (s1) в качестве первого аргумента и все элементы из второго среза (s2) в качестве второго. Возвращается обновленный срез со всеми элементами из s1 и, который может быть присвоен другой переменной.

```go
s1 := []int{1, 2, 3}
s2 := []int{4, 5, 6}

s3 := append(s1, s2...)
fmt.Println(s3) // output: [ 1, 2, 3, 4, 5, 6 ]
```

10. Как можно нарезать слайс? Какие есть нюансы, подводные камни?
Можно сделать подсалайс из слайса или массива:
```go
slice := []int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}
subSlice := slice[3:8] // [ 4, 5, 6, 7, 8 ]
```

Нюанс в том, что если мы изменим или добавим значение в сабслайс, то это значение изменится/добавится и в базовый слайс

```go
subSlice[0] = 101

fmt.Println(slice) // [1 2 3 101 5 6 7 8 9 10]
fmt.Println(subSlice) // [101 5 6 7 8]
```

Видим, что в базовом слайсе тоже поменялись значения, а все потому, что у под слайса все тот же базовый массив, а для подслайса нулевой элемент это элемент под индексом 3 в базовом. Примерно такое же поведение наблюдается у функции append, если его применить к под слайсу базового слайса:
```go
slice := make([]int, 10, 25)
subSlice := slice[3:5] // [ 0, 0]

fmt.Println(len(slice), cap(slice)) // 10 25
fmt.Println(len(subSlice), cap(subSlice)) // 2 22

subSlice = append(subSlice, 11)

fmt.Println(slice) // [0 0 0 0 0 11 0 0 0 0]
fmt.Println(subSlice) // [0 0 11]
```
причина данного поведения в том, что у обоих слайсов один базовый массив, а так же у под слайса своя "копия" слайса с полями len и cap и когда мы пытаемся добавить в дочерний слайс элемент, при условии, что в родитльском хватает емкости, мы просто перезаписываем значение в базовом массива.

---
### Maps

1. Что такое Map? Как устроен в Go? Желательно приблизительно понимать структуру (type hmap struct) и его поля
   Map - структура данных, ассоциативный массив или хэш-таблицу типа ключ-значение. Он позволяет хранить пары "ключ-значение", где каждый ключ уникален, и используется для быстрого доступа к значениям по ключам.
   **Основные понятия**:
   - Хэш-функция 
   - Бакет
   - Коллизия

```go
// Header for a Go map
type hmap struct {
	count      int    // размер мапы. используется функцией len()
	flags      uint8 
	B          uint8  // log_2 количество бакетов. Для 8 бакетов B=3, для 16 B=4 
	noverflow  uint16 // примерное число переполненных бакетов
	hash0      uint32 // seed для хэша. всегда задаётся и генерируется при создании мапы
	
	buckets    usafe.Pointer  // указатель на массив 2^B бакетов; nil eсли count=0
	oldbuckets unsafe.Pointer // указатель на массив предыдущих бакетов. для эвакуации 
	nevacuate  uintptr        // количество "эвакуированых" бакетов
	
	extra      *mapextra      // опциональные поля
}

// Bucket for a Go map
type bmap struct {
	tophash [bucketCnt]uint8  // массив tophash
	// После массива tophash идет массив размера bucketCnt ключей и массив размера bucketCnt элементов
}
```
   
2. Что такое хеш-функция?
   Под ней понимают функцию, которая принимает значение (ключ) неопределенного размера и возвращает значение фиксированной длины. В случае c Go она возвращает `uint64`. Одно из главных свойств - стабильность. Для одного и того же переданного значения она должна возвращать один и тот же результат;
   **Основные характеристики хеш-функций**:
   - Фиксированный размер выходных данных: Независимо от размера входных данных, хеш-функция всегда возвращает значение фиксированной длины. Например, хеш-функция SHA-256 всегда возвращает 256 бит (32 байта).
   - Детерминированность: Для одного и того же входного значения хеш-функция всегда будет возвращать одно и то же хеш-значение. 
   - Быстрота вычисления: Хеш-функции должны быть достаточно быстрыми для вычисления, чтобы их можно было использовать в реальном времени.
   - Устойчивость к коллизиям: Хорошая хеш-функция должна минимизировать вероятность коллизий, то есть ситуации, когда два разных входных значения дают одинаковый хеш. Хотя коллизии возможны (особенно для хеш-функций с фиксированным размером), хорошая хеш-функция делает их редкими.
   - Односторонность: Для криптографических хеш-функций важно, чтобы было невозможно восстановить исходные данные из хеш-значения. Это свойство называется односторонностью.
3. Почему нельзя брать адрес на значение, хранящееся по ключу в map?
   - Нельзя получить адрес элемента. Потому что при росте мапы оно переедет в другой бакет и адрес у него, соответственно, поменяется;
     
4. Что такое эвакуация, и в каком случае она будет происходить?
   Рост мапы начинается в двух случаях:   
   - Бакеты в среднем заполнены на больше чем 80%. В таком случае количество бакетов увеличивается примерно вдвое
   - Второй (частный) случай разобрать позднее
   
   Сам алгоритм несложный (практически) - проходим по все элементам в бакете, выбираем новый бакет и переносим ключ (рехешируем), значение и топхеш.  
   При росте мапы количество бакетов увеличивается вдвое. Если разделить слайс новых бакетов на две половины, то для каждого элемента внутри старого бакета есть два пути ~~this is the way~~ - либо в первую половину либо во вторую. А если считать каждую половину новых бакетов _отдельным_ слайсом, то можно сказать что в пределах такой половины индекс бакета для элемента не поменяется.
   
> [!NOTE] Пример
> Было 8 бакетов, мы начали рост, количество бакетов удвоилось и стало 16. В таком случае каждый элемент бакета по индексу 3(четвертый бакет) перенесется либо в бакет в первой половине по индексу 3, либо во второй по индексу 11 (3+8). Соответственно последний бакет с индексом 7 переносится либо в 7ой либо в 15й(7+8).


5. Какие есть особенности синтаксиса получения и записи значений в map?   
6. Как происходит поиск по ключу в map?
	Осуществляется с использованием хэш-таблицы, что позволяет выполнять операции поиска, вставки и удаления с высокой эффективностью.
   - Применение хэш-функцию к ключу. Преобразуется ключ в хэш-значение, которое представляет собой целое число
   - Определение индекса в ведра. Индекс вычисляется с использованием операции взятия по модулю от размера массива ведер.
   - Поиск в ведре. Каждое ведро может содержать несколько пар "ключ-значение", особенно в случае коллизий (когда два разных ключа имеют одинаковое хэш-значение). Ведра могут реализовываться как связанные списки или другие структуры данных. Если ведро пустое - ключ не существует в map и возвращает exists false и нулевое значение. Если ведро содержит элементы, Go перебирает пары "ключ-значение" в этом ведре и сравнивает ключи с искомым ключом. Если ключ найден, возвращается соответствующее значение. 
8. Каков порядок перебора map?

   Порядок итерации не сохраняется. При каждой новой итерации мапы последовательность возвращаемых элементов может отличаться. Под капотом каждый раз выбирается рандомный бакет, с которого начинается итерация. Для сохранения нужного порядка придется сохранять ключи в отдельном массиве и итерироваться по нему;
10. Что будет происходить при конкуррентной записи в map? Как можно решить эту проблему?
   
    В Go встроенный тип данных `map` не является потокобезопасным (concurrency-safe). Это означает, что если несколько горутин одновременно обращаются к одной и той же карте **и** хотя бы одна из них пытается вносить изменения (добавлять, удалять или обновлять элементы), то возникнет состояние гонки. В лучшем случае Go-рантайм выбросит panic вида «concurrent map read and map write» или «concurrent map writes», а в худшем — произойдут более сложные ошибки, связанные с порчей данных.
   - Внутренняя реализация map в Go не предназначена для конкурентных изменений без дополнительной синхронизации.
   - Любые операции записи (вставка, удаление, обновление) могут менять внутренние структуры (хэш-таблицы), что приводит к неконсистентным данным, если несколько горутин модифицируют их одновременно.
    **Как решить проблему?**
    - sync Mutex, sync.RWMutex - примитив синхронизации. Обращение к полю `m` напрямую должно быть закрыто для внешнего кода. Все операции выполняются только через методы, защищённые мьютексом.
    - sync.Map - Начиная с Go 1.9 в стандартной библиотеке есть тип `sync.Map`, специально предназначенный для потокобезопасного хранения данных. Он реализует свои внутренние механизмы синхронизации и подходит для высокопараллельных сценариев, где ключи и значения могут часто меняться. Однако `sync.Map` имеет свои особенности и не всегда даёт выигрыш:
      Он оптимизирован для сценариев «write-once, read-many» — часто чтения и редко записи.
    - В некоторых случаях можно выстроить доступ к карте через отдельную горутину, которая «владеет» структурой данных, а все операции выполняются по каналам (channel). Так достигается модель «актора»: чтения и записи производятся последовательно внутри одного потока. Это упрощает логику, но требует дополнительного кода для маршрутизации операций.
---
### Channels

1. Что такое канал? Чем отличается буферизированный канал от небуферизированного?

Канал — это механизм в Go для безопасной передачи данных между горутинами.
Отличия:

Небуферизированный канал (make(chan T)):
Отправка блокирует отправителя, пока получатель не готов принять данные (и наоборот). Синхронная передача.
Буферизированный канал (make(chan T, N)):
Отправка блокируется только при заполнении буфера (ёмкости N), а чтение — при пустом буфере. Асинхронная передача.

2. Как создать канал? Как закрыть канал?

```go
chUnbuffered := make(chan int)    // Небуферизированный
chBuffered := make(chan int, 10)  // Буферизированный
```

```go
close(chBuffered)  // Закрывает канал (выполняется отправителем)
```
3. Как читать из канала и писать в канал?

Запись: ch <- 42
(блокирует, пока данные не будут получены или пока есть место в буфере).
Чтение: value := <-ch или value, ok := <-ch (если ok == false, канал закрыт).

4. Зачем нужны в целом каналы?

- Синхронизация горутин.
- Безопасная передача данных без гонок (race conditions).
- Реализация паттернов: producer-consumer, worker pools и т.д.

5. Что будет, если читать из закрытого канала?

Когда канал закрыт (с помощью встроенной функции close(ch)), дальнейшие операции чтения (получения значений) из него дают нулевое (zero) значение типа и признак, что канал закрыт. В Go обычно чтение из канала оформляют так:

```go
v, ok := <-ch
```
v — это значение, считанное из канала (при закрытом канале это будет zero value);
ok — булево значение, которое при закрытом канале будет false.

При этом чтение из закрытого канала не вызывает панику и не блокируется: если канал закрыт и данных в буфере нет, возвращается zero value и ok == false.

6. Что будет, если писать в закрытый канал?

Вызывает панику 

7. Что будет если закрыть закрытый канал?

Вызывает панику 

8. Что такое nil канал и что будет если писать и читать от туда?


Nil канал - неинициализированный канал, который никуда не указывает. Если попытаться сделать send (операция записи) или receive (операция чтения) из такого канала, то соответствующая горутина будет блокироваться навсегда. Причём никакой ошибки на уровне компиляции или рантайма при этом не возникает — просто программа «зависает» на такой операции.

---
### Strings

1. Что из себя представляет тип данных string в языке Golang? Можно ли изменить определенный символ в строке? Что происходит при склеивании строк?

Строки же представляют собой _неизменяемый_ последовательный набор байт _фиксированного размера_. Это означает, что вы не можете изменять строки — только создавать новые. Это важно понимать в контексте производительности программы. В программах, где нужна очень высокая производительность, постоянное создание большого количества строк создаст ощутимую нагрузку на сборщик мусора.
   
   При склеивании строк в Go создается новая строка, которая содержит объединенное содержимое. Вы можете использовать оператор `+` для склеивания строк:
   
   При каждом склеивании строк создается новая строка, и если вы часто выполняете операции склеивания, это может привести к неэффективному использованию памяти (см выше). В таких случаях рекомендуется использовать `strings.Builder`, который оптимизирован для построения строк:
   
```go
package main

import (
	"fmt"
	"strings"
)

func main() {
	var builder strings.Builder
	builder.WriteString("Hello, ")
	builder.WriteString("world!")
	result := builder.String()
	fmt.Println(result)
}

```

2. Как можно оперировать строками?
  -  Конвертация (в срез байтов, срез рун)
  -  Функции пакета strings
  - Работа с regexp
  -  Конкатенация 
	  - + - В большинстве случаев такого подхода достаточно (Go оптимизирует конкатенацию при компиляции, если строковые литералы).
	  - fmt.Sprintf - Cоздание строки с форматированием
	  - string.Builder - Эффективная по памяти и времени сборка строки в циклах
3. Что будет если сложить строки?

Новая строка из сложенных двух. При каждом сложении создаётся новый объект типа `string`. Если внутри цикла многократно использовать `s = s + something`, то на каждом шаге будет происходить дополнительная аллокация памяти, что может приводить к существенным накладным расходам.
4. Как определить количество символов для строки?

Нужно понимать, что при функции *len* возвращается количество байтов в строке, а не число символов. Строки в Go хранятся в UTF-8 
   Чтобы получить именно **количество символов** (количество рун), есть два основных способа:
   - **Сконвертировать строку в срез рун** и измерить его длину:
   - **Использовать пакет `unicode/utf8`** и функцию `utf8.RuneCountInString`:
```go
import "unicode/utf8"

s := "Привет"
fmt.Println(utf8.RuneCountInString(s)) // 6
```
```go
s := "Привет"              // 6 символов
r := []rune(s)
fmt.Println(len(r))        // 6
```
 
5. Какие есть нюансы при итерации по строке?

Итерация «по рунам» (через `for range`)
   Итерация по байтам в обычном for
```go
s := "Привет"
for i, r := range s {
    fmt.Printf("Byte index: %d, rune: %c\n", i, r)
}

```
```go
s := "Привет"
for i := 0; i < len(s); i++ {
    fmt.Printf("Index %d: byte = %x\n", i, s[i])
}

```
	
6. Как эффективно склеивать строки (конкатенация строк)?
   - **`+`** и **`fmt.Sprintf`**: когда конкатенации немного (пара строк) или нужно форматирование.
   - **`strings.Builder`** (или `bytes.Buffer`) для многократных, последовательных операций, особенно в цикле. Это наиболее эффективный способ.
   - **`strings.Join`** для быстрого объединения готового среза строк через разделитель.
---
### Types

1. Какие бывают типы в Go? Целочисленные, дробные, комплексные, структуы, интерфесы, время и дополнить.

**Базовые типы**
- Логические (bool)
- Числовые (int, uint, (u)int8, (u)int16, (u)int32, (u)int64, byte(uint8), rune(int32), float32, float64, complex64, complex128)
- Строки (string)
- Составные (array, slice, map, struct, pointer, function, chan, interface)
- Пользовательские типы
  ```go
  type Celsius float64
  type UserID int
  ```
**Подытожим**

Скалярные типы: bool, числовые (целочисленные, вещественные, комплексные) и string.

Составные типы: массивы, срезы, карты (map), структуры (struct), указатели, каналы и функции как значения.

Интерфейсы: описывают набор методов, реализуемых типами.

Стандартная библиотека: содержит важные типы вроде time.Time, error (тоже интерфейс) и многие другие.

Пользовательские типы: могут быть объявлены на основе существующих (новый тип) или алиаса (только переименование).
  
2. Отличие uint от int?

Unsigned int - безнаковый инт (хранит только нулевые и положительные числа)
Int - хранит отрицательные, нулевые и положительные числа

3. Что такое обычный int и какие есть нюансы его реализации?

Размер int зависит от архитектуры
- 32 бита на 32-битных системах
- 64 бита на 64-битных системах.

В Go есть типы с фиксированным размером: int8, int16, int32, int64.
int не является синонимом int32 или int64 — это отдельный тип.
Для переносимости лучше использовать int для общих случаев, а int32/int64 — когда нужна точность (например, работа с бинарными данными).

**Кейс с переполнением**
```go
var a int8 = 127
a += 1 // Станет -128 (без ошибки в runtime)

const b int8 = 128 // Ошибка компиляции: overflows int8
```

**Когда использовать int**
Для индексов массивов, срезов и длины строк (например, len(slice) возвращает int).
В общих вычислениях, где не требуется фиксированный размер.
Для совместимости с системными вызовами и библиотеками, зависящими от архитектуры.

4. Как преобразовать строку в int и наоборот? Можно ли сделать int(string) и string(int) соответственно?

Нет, проблема сопоставимых типов. Просто так, используя int(s) и string(i) не получится
Можно использовать strconv

**Почему int(s) и string(i) не работает?**
- int(s) - не поддерживает прямое преобразование
- string(n) — интерпретирует число как код символа Unicode, а не строковое представление числа

5. Сколько в памяти занимают реализации int32 и int64?

int32 - 32 / 8 = 4. 8 байтов
int64 - 64 / 8 = 8. 8 байтов

6. Какие предельные значения int32 и int64?

int32: -2 147 483 648 до 2 147 483 647
int64: -9 223 372 036 854 775 808 до 9 223 372 036 854 775 807

7. Какой результат получим если разделить int на 0 и float на 0?

При делении int на 0 - panic
При делении float на 0 - Inf (бесконечность). Если float > 0 - +Inf (отрицательная бесконечность), Если float < 0 -Inf (отрицательная бесконечность)

8. Что такое константы и можно ли их изменять?

Нет, это неизменяемое именное значение, которое определяется во время компиляции

9. Что такое iota?

----

10. Что такое структура (stuct) в Go? Зачем они нужны?

Структуры - пользовательский тип данных. Служит для хранения набора полей и привязанных к ней методов под одним именем. Основной способ создания сложных структур данных (slice, maps, channels).

**Ключевые особенности**
- Значения по умолчанию. Поля структуры инициализируются нулевыми значениями своих типов.
- Сравнение структур. Структуры можно сравнивать оператором ==, если все их поля сравнимы.
- Встраивание. Поля и методы встраимовой стркутуры доступны и в ребёнке.
- Инкапсуляция. Поля и методы структур, начинающиеся с строчной буквы, недоступны вне пакета.
- Выравнивание

**Структуры делают код:**

→ Читаемым
→ Модульным
→ Легким для тестирования


11. Что такое метод? Как они выглядят?

Метод - функция, которая привязана к какой-либо типу данных. Чаще всего к структурам.
**Синтаксис метода**
```go
// func (получатель) ИмяМетода(параметры) возвращаемые_значения { ... }
func (u User) Greet() string {
    return fmt.Sprintf("Привет, %s!", u.Name)
}
```
Receiver - объявление типа, с которым связываем метод
**Типы получателей**
- По значению (value receiver). Создаётся копия объекта. Изменения внутри метода не влияют на поля оригинала.
- По указателю (pointer receiver). Работает с оригиналом через указатель. Изменения сохраняются.

```go
func (u User) UpdateName(newName string) {
    u.Name = newName // Изменяется только копия
}

user := User{Name: "Анна"}
user.UpdateName("Мария")
fmt.Println(user.Name) // "Анна" (оригинал не изменился)
```

```go
func (u *User) UpdateName(newName string) {
    u.Name = newName // Меняем оригинал
}

user := &User{Name: "Анна"}
user.UpdateName("Мария")
fmt.Println(user.Name) // "Мария"
```

**Особенности методов**
- Методы можно привязывать к любому типу (не только структурам), если тип объявлен в том же пакете.
- Нельзя привязать метод к встроенным типам (int, string) напрямую — нужно создать кастомный тип:
```go
  type MyString string

func (s MyString) Reverse() string {
    // ...
}
```

Методы в Go — это способ связать функции с данными, что делает код:
- Более организованным
- Поддерживающим принципы инкапсуляции
- Готовым к использованию интерфейсов

12. Как осуществляется наследование в Go?

В Go нет стандартного механизма наследования. Осуществляется засчёт встраивания (композиции) родительского класса в ребенка.
Это означает, что для повторного использования кода и достижения полиморфизма вы создаёте структуры, которые включают в себя другие структуры, а не наследуют от них.

Разница встраивания и композиции
- Встравивание позволяет включать один тип в другой
- Композиция позволяет использовать тип в качестве поля, но без встраивания. И к полям этого типа мы обращаеся через поле нашего типа.

```go
type A struct {
    Field1 int
}

type B struct {
    A // Встраивание структуры A
    Field2 string
}

```
```go
type A struct {
    Field1 int
}

type B struct {
    A A // Композиция: A является полем B
    Field2 string
}
```

13. Что такое тип rune? Зачем их использовать?

Тип Rune - allias типу int32. Он предназначен для работы с символами, которые могут занимать более одного байта в кодировке UTF-8. Используется для работы с символами из кодировки Unicode.
- Строки в Go хранятся в виде последовательность byte, которые закодированы в последовательности UTF-8. Многие символы занимают более 1 байта (эмодзи, иероглифы).
- Итерация по строке (for range) возвращает символы в rune.

14. Что такое тип byte?

Тип Byte - allias типа uint8. Основное назначение - удобное обозначение единицы байта. Удоно работать со строками, источниками двоичных данных (файлы, протоколы)

15. Что такое goto?

Оператор безусловного перепрыгивание на другой блок кода внутри одной функции.
```go
package main

import "fmt"

func main() {
    i := 0
start:
    if i < 5 {
        fmt.Println("i =", i)
        i++
        goto start  // переход к метке start
    }
}
```
Может быть полезным при выходе из вложенных циклов

16. Какие циклы есть в Go?

Существует только одно ключевое слово для цикла - for. Но с разынми конструкциями.
```go
for i:= 0; i <= 10; i++ {
	// классический for
}
```
```go
i := 0
for i < 10 {
	// цикл, подобный while
	//...
	i++ 
}
```
```go
for {
	// бесконечный цикл
}
```

```go
slice := []int{10, 20, 30, 40}
for index, value := range slice {
	// цикл с итерацией по объекту
    fmt.Printf("Индекс: %d, Значение: %d\n", index, value)
}
```
---
### Interfaces

1. Что такое интерфейсы в Go? Чем отличается от интерфейсов в дпугих языказ, например, Java, PHP. Что такое утиная типизация?
2. Внутренее устройство интерфейса, какое оно (структура iface, itab)?
3. Сделать интерфейс для вычисления площади круга и квадрата, реализовать их в структурах cicle и square.
4. Что такое пустой интерфейс?
5. Что такое nil интерфейс?
6. Что такое type switch?
7. Как определить тип интерфейса?
8. Как преобразовать интерфейс к другому типу?
9. Где следует поместить описание интерфейса: в пакете с реализацией или в пакете, где этот интерфейс используется? Почему?
---
### Runtime Go

1. Что такое runtime (планировщик sheduler)? Как он устроен в Go?

Runtime Go - среда выполнения Go кода.
Сотоит из:
- Scheduler - отвечает за управление горутинами и распределение их на систмемные потоки.
- GC
- Syscalls

Scheduler основан на M:N (потоки:горутины) модели, где:
- **G**oroutine - отдельная горутина, сущность легковесных потоков в Go (что исполняем)
- **M**achine - Системный поток ОС (где исполняем)
- **P**rocessor - Логический процессор планировщика Go (очередь горутин)

**Как связаны GMP**
Горутины (G) планируются и исполняются через планировщик (P)
M поднимают P и исполняют горутины из очереди P
Число P по умолчанию соответствует GOMAXPROCS. Если 8 ядер, обычно Go сам выставляет GOMAXPROCS=8, значит будет 8 P.

2. Что такое Gorutine (горутина)?

Легковесный поток, которые планируются и управляются внутри Go Scheduler. Расположены в очередях P
В отличии от системных потоков более легковесны. Планирование, хранение и переключение между ними намного "дешевле" по ресурсам.
Имеют свой собственный стек, который динамически расширяется. Как правило начинается с 2Кб.
Просты для работы со стороны разработчика прозрачны.
Синхронизируются и общаются через Каналы (см. пункт "Channels")

3. В чем отличие горутины от потока?

См. пункт 2

4. Как устроены горутины, сколько памяти они занимают в стеке?

Каждая горутина хранит контекст
- Стек вызовов (для локальных переменных и выполнения функций).
- Указатель на текущую инструкцию.
- Информацию о каналах, блокировках и других зависимостях.

Динамический стек
Начальный размер: Стек горутины начинается с 2 КБ (в современных версиях Go, ранее было 4 КБ).
Динамическое расширение: Если стек переполняется, Go автоматически выделяет новый стек большего размера (в 2 раза), копирует в него данные и перенаправляет указатели.
Непрерывный стек: В отличие от ранних версий (сегментированный стек), сейчас стек растет как непрерывная область памяти, что уменьшает накладные расходы.


5. Кто управляет горутинами? Какой тип многозадачности используется в Go и какой был до версии Go 1.15?

Горутинами управляет Scheduler (см. пункты 1-3). 
До версии 1.15 он был только кооперативным, с более новых версий - гибридный (кооперативновытесняющий).

Кооперативный - горутина сама говорит, когда её нужно переключить. Происходит это в cooperative points (вызов функций, создание горутины, работа с каналами, syscalls). То есть те места, где горутина может захватить поток на долгое время
Вытесняющий - Scheduler сам выводит горутину. То есть горутина может быть прервана даже в длинном вычислительном цикле, когда нет явных операций с runtime. 

Как работает вытеснение в Go
Флаг прерывания: Каждая горутина имеет флаг в своем стеке, который проверяется при каждом вызове функции. Если флаг установлен, горутина приостанавливается.
Планировщик периодически отправляет SIGURG потоку ОС, в котором выполняется "застрявшая" горутина. Обработчик сигнала устанавливает флаг прерывания в стеке горутины.

Тайминг вытеснения
Интервал мониторинга: Планировщик отслеживает горутины, которые выполняются дольше 10 мс в одном потоке ОС.
Принудительное прерывание: Если горутина не уступает управление добровольно, через 10 мс ей отправляется сигнал SIGURG.

6. Что такое GC (garbadge collector/сборщик мусора)?

Механизм Go рантайма, который автоматически освобождает неиспользуемую (устаревшую) память внутри heap.
GC ищет объекты, на которые нет «живых» ссылок (не используется ни одной горутиной), и очищает их, освобождая пространство под другие нужные объекты.

7. Как работает сборщик мусора в Go?

Основной алгоритм работы - Mark and Sweep c короткими паузами STW (Stop The World).

Stop The World. Остановка всех горутин. Инициализация процесса маркировки. Сканирование корневых объектов (глобальные переменные, стеки всех горутин, указатели в куче) 

Конкурентная марикровка. 

Параллельно с выполнением программы: Сборщик помечает все объекты, достижимые из корневых точек, как активные. 

Использует триколорную маркировку (black, grey, white): 

Чёрный: Объект проверен, его дочерние элементы тоже проверены. 
Серый: Объект проверен, но его дочерние элементы ещё нет. 
Белый: Объект не проверен (потенциальный мусор). 

Write Barrier: Механизм, который отслеживает изменения ссылок во время маркировки, чтобы не пропустить новые связи.

Очистка. Параллельно с программой: Освобождает память, занятую белыми (недостижимыми) объектами. Возвращает память в кучу для повторного использования.

8. Как проверить тип переменной в среде выполнения?

Есть несколько способов проверки типа при Runtime:
**Type assertion**
```go
var value interface{} = "hello"

// Проверка и преобразование
str, ok := value.(string)
if ok {
    fmt.Println("Это строка:", str) // Это строка: hello
} else {
    fmt.Println("Не строка")
}
```

**Type Switch**
```go
func checkType(v interface{}) {
    switch v.(type) {
    case int:
        fmt.Println("Это int")
    case string:
        fmt.Println("Это string")
    default:
        fmt.Printf("Неизвестный тип: %T\n", v)
    }
}

func main() {
    checkType(42)       // Это int
    checkType("hello")  // Это string
    checkType(3.14)     // Неизвестный тип: float64
}
```

**Использование пакета Reflect**
```go
package main

import (
    "fmt"
    "reflect"
)

func main() {
    var x float64 = 3.14
    fmt.Println(reflect.TypeOf(x)) // float64

    y := []int{1, 2, 3}
    fmt.Println(reflect.TypeOf(y)) // []int
}
```
Нужно понимать!
- Type Assertion может вызывать панику, если тип не совпадает. Поэтому нужно использовать форму с проверкой value, ok := ...
- Reflect нагладывает оверхед на код 
---
### Testing

1. Что такое runtime (планировщик sheduler)? Как он устроен в Go?
2. Что такое Gorutine (горутина)?
3. В чем отличие горутины от потока?
4. Как устроены горутины, сколько памяти они занимают в стеке?
5. Кто управляет горутинами? Какой тип многозадачности используется в Go и какой был до версии Go 1.15?
6. Что такое GC (garbadge collector/сборщик мусора)?
7. Как работает сборщик мусора в Go?
8. Как проверить тип переменной в среде выполнения?
---
### CI/CD

0. Что такое CI/CD?

CI/CD (от англ. Continuous Integration / Continuous Delivery или Deployment) — это набор практик и инструментов, которые помогают автоматизировать и упрощать процесс разработки, тестирования и релиза программного обеспечения.

Основные аспекты CI/CD:

1. **Continuous Integration (непрерывная интеграция)**
    
    - Разработчики часто (как правило, несколько раз в день) сливают (merge) свой код в общую ветку репозитория.
    - После каждого слияния автоматически запускаются проверки кода (юнит-тесты, статический анализ, сборка проекта и т. д.).
    - Цель — быстро обнаруживать и исправлять проблемы в коде, избегая «эффекта снежного кома», когда мелкие ошибки накапливаются и усложняют релиз.
2. **Continuous Delivery (непрерывная поставка)**
    
    - После успешной интеграции и тестирования код становится готовым к выпуску.
    - Главная идея — иметь всегда «готовый к деплою» код, то есть любой «зелёный» (успешно прошедший проверки) коммит можно развернуть в рабочем окружении.
    - Реальный релиз (деплой) может проводиться автоматически или вручную по решению команды, но процесс подготовки к релизу максимально автоматизирован и повторяем.
3. **Continuous Deployment (непрерывный деплой)**
    
    - Это расширение идеи непрерывной поставки. Если все тесты пройдены успешно, новая версия автоматически разворачивается в рабочем окружении (production).
    - Такой подход требует высокого уровня зрелости процессов, тестов и мониторинга, поскольку изменения выкатываются без ручных промежуточных шагов.

### Зачем это нужно?

- **Минимизировать риски**: небольшие, часто тестируемые изменения проще откатить или исправить, чем крупные блоки кода.
- **Сократить время вывода продукта на рынок**: автоматизация уменьшает задержки между написанием кода и его релизом.
- **Повысить качество**: постоянные тесты и проверки помогают быстро обнаруживать регрессии и ошибки.
- **Упростить командную работу**: слияние изменений в общий репозиторий часто стимулирует лучшую коммуникацию и избавляет от конфликтов при объединении крупных фич.

Таким образом, CI/CD помогает командам выпускать качественные обновления быстрее и надежнее, делая процесс развертывания предсказуемым и повторяемым.

1. Что такое линтеры (linters) зачем они нужны и как их использовать?

Линтеры- инструмент для анализа статического кода, которые находит ошибки по заданным настройкам.
- Синтаксические ошибки
- Нарушение кодстайла
- Потенциальные ошибки
- Оптимизаций и предупреждений о неиспользуемом коде

**Популярные линтеры**
- golangci-lint — наиболее популярный линтер, объединяющий более 50 инструментов проверки.
- govet — встроенный в Go инструмент для поиска проблем в коде.
- gofmt / goimports — автоформатирование и сортировка импортов
  
2. Как можно измерить использование памяти в Go? Что такое pprof?

Инструмент плофилирования. Позволяет собирать детальные профили, анализировать распределение памяти, искать утечки и оптимизировать использование ресурсов. pprof является мощным инструментом для глубокого анализа производительности приложения.

Можно измерять память с помощью runtime.Memstats
- **Alloc** — количество байт, выделенных и используемых в текущий момент.
- **TotalAlloc** — общее число байт, когда-либо выделенных.
- **Sys** — общее количество байт, полученных от операционной системы.
- **NumGC** — количество выполненных сборок мусора.


3. Что такое Prometheus и Grafana? Зачем они нужны?

Prometheus, Graphana - инструменты-системы по мониторингу, сбору необходимых метрик, визуализации данных.

**Prometheus**
 **Что это:**  
    Prometheus — это система мониторинга и оповещения с открытым исходным кодом. Она была разработана для сбора, хранения и обработки метрик в виде временных рядов (time series data).
    
- **Основные возможности:**
    
    - **Сбор метрик:** Prometheus периодически запрашивает (scrapes) данные с различных источников, таких как приложения, серверы, базы данных и прочие компоненты инфраструктуры.
    - **Хранение данных:** Собранные данные сохраняются в собственной временной базе данных, что позволяет быстро получать доступ к историческим метрикам.
    - **Язык запросов PromQL:** Предоставляет гибкий язык запросов для выборки и анализа метрик.
    - **Оповещения:** Возможность настройки правил оповещения, чтобы уведомлять команды о возникновении проблем в работе системы.
- **Зачем нужен:**  
    Prometheus позволяет централизованно мониторить состояние приложений и инфраструктуры, обнаруживать проблемы, анализировать производительность и автоматически реагировать на возникновение аномалий.

**Graphana**
- **Что это:**  
    Grafana — это платформа для визуализации данных и создания интерактивных дашбордов. Она поддерживает множество источников данных, включая Prometheus, и позволяет отображать метрики в виде графиков, диаграмм, таблиц и других визуальных компонентов.
    
- **Основные возможности:**
    
    - **Визуализация данных:** Создание наглядных и настраиваемых панелей для отображения метрик в реальном времени.
    - **Поддержка различных источников данных:** Помимо Prometheus, Grafana может работать с InfluxDB, Elasticsearch, MySQL, PostgreSQL и другими.
    - **Алертинг:** Возможность настройки оповещений непосредственно в интерфейсе, чтобы оперативно информировать о проблемах.
    - **Интерактивность:** Пользователи могут исследовать данные, задавать фильтры, настраивать временные интервалы и получать детальную информацию.
- **Зачем нужен:**  
    Grafana помогает превратить сырые данные в понятные и удобные для анализа визуальные представления. Это облегчает отслеживание ключевых показателей, выявление трендов и оперативное реагирование на изменения в состоянии системы.

**Совместное использование**
- **Мониторинг и анализ:**  
    Prometheus собирает и хранит метрики, а Grafana обеспечивает их наглядное отображение. Вместе они позволяют получить полное представление о состоянии и производительности систем.
    
- **Централизованное управление:**  
    Использование этих инструментов позволяет командам быстро обнаруживать проблемы, проводить анализ производительности и принимать обоснованные решения по оптимизации работы приложений и инфраструктуры.
    
- **Простота интеграции:**  
    Благодаря открытым API и стандартным форматам обмена данными, настройка Prometheus и Grafana относительно проста, что делает их популярным выбором для DevOps и SRE команд.  

---
### Other

1. Зачем используется ключевое слово defer в Go?

Defer - ключевое слово для отложенного выполнения блока кода. Это озночает, что вызов функции defer будет выполнено после завершения окружающей функции. Но до выхода из нее.
Используется для высвобождения ресурсов (подключений, мьютексов).

2. Каков порядок возврата при использовании несколько функций с defer в рамках одной внешней функции?

По правилу стека LIFO - (Last in first out). 
```go
package main

import "fmt"

func main() {
    defer fmt.Println("Выполнится третьим")
    defer fmt.Println("Выполнится вторым")
    defer fmt.Println("Выполнится первым")
}

```
```
Выполнится первым
Выполнится вторым
Выполнится третьим

```


3. Как передаются значения в функции, перед которыми указано ключевое слово defer? Пример:

```go
func main() {
	nums := 1 << 5 // 32

	defer fmt.Println(nums) // тут как?

	nums = nums >> 1 //16

	fmt.Println("done")
}
```

При использовании defer аргументы функции вычисляются сразу, в тот момент, когда встречается выражение defer, а не во время фактического выполнения отложенной функции. Это означает, что значение переменной, используемой в отложенном вызове, фиксируется в момент объявления defer.

- Запоминаем переменную nums = 32
- Даже если переменная nums позже изменится (в данном случае станет равной 16), отложенный вызов всё равно будет использовать сохранённое значение 32.
- Таким образом, после вывода "done", отложенный вызов напечатает число 32.

4. Какие бывают способоы синхронизации данных в Go? (про каналы тоже не забываем)

- Atomics
- Sync пакет (WaitGroup, Mutex, Pool, Once, Cond)
- Channels
- Context

WaitGroup - используется для ожидания завершения горутины. Удобна, когда нужно синхронизировать выполнение, чтобы основная горутина не завершалась до конца выполнения задач.
```go
package main

import (
    "fmt"
    "sync"
)

func main() {
    var wg sync.WaitGroup

    for i := 0; i < 5; i++ {
        wg.Add(1)
        go func(id int) {
            defer wg.Done()
            fmt.Println("Горутина", id, "завершена")
        }(i)
    }

    wg.Wait()
    fmt.Println("Все горутины завершены")
}

```

Once - гарантирует, что функция будет выполнена только один раз. Удобна для инициализации ресурсов. 
```go
package main

import (
    "fmt"
    "sync"
)

func main() {
    var once sync.Once
    initFunc := func() {
        fmt.Println("Инициализация выполнена")
    }

    for i := 0; i < 5; i++ {
        go once.Do(initFunc)
    }

    // Даем время горутинам на выполнение
    fmt.Scanln()
}
```

Pool - Этот механизм помогает управлять повторным использованием объектов, снижая нагрузку на сборщик мусора, хотя он и не относится напрямую к синхронизации, но помогает в работе с разделяемыми ресурсами.


5. Что такое mutex, какие они бывают и как их использовать?

Mutex - примитив синхронизации, который управляет конкурентным доступом к общим ресурсам. Разрашает эксклюзивный доступ к разделяемому ресурсу. Он гарантирует, что в критической секции кода, где происходит работа с разделяемыми данными, одновременно может находиться только одна горутина (или поток).

**Как работает мьютекс**
В мьютексе содержится внутренее состояние (locked/unlocked) + очередь ожидающих горутин.
- Состояние locked - Мьютекс занят. Горутина, которая "долбится" в мьютекс отправляется в ожидаение
- Состояние unlocked - Мьютекс доступен для захвата.

Захват Мьютекса - Горутина вызывает метод Lock
- Проверка состояния: Если мьютекс свободен (unlocked), то он сразу переходит в состояние locked, и горутина получает «право» на выполнение критической секции.
- Если мьютекс занят: Если мьютекс уже находится в состоянии locked, горутина должна приостановить своё выполнение (заблокироваться) до тех пор, пока мьютекс не будет освобожден.
- Очередь ожидания: Внутренне могут поддерживаться данные о том, какие горутины ожидают захвата мьютекса, что позволяет при освобождении мьютекса разбудить ожидающих.

Работа в критической секции - При захвате Lock
После успешного захвата мьютекса (вызывая Lock()) горутина входит в критическую секцию, где она может безопасно изменять разделяемые данные. Так как никакая другая горутина не сможет получить доступ к защищённому участку до освобождения мьютекса, это предотвращает состояния гонок (race conditions).

Освобождение Мьютекса - Вызывается метод Unlock
- Смена состояния: Мьютекс переводится обратно в состояние unlocked.
- Разблокировка ожидающих горутин: Если в очереди ожидания есть горутины, одна из них (обычно следующая в очереди) пробуждается и пытается захватить мьютекс.

**Виды мьютексов**
- sync.Mutex - Базовый тип мьютекса. Обеспечивает простое блокирование и разблокирование критической секции.
- sync.RWMutex - Read - Write mutex. Позволяет блокировать мьютекс на запись, но несколько горутин могут захватывать мьютекс на чтение. Позволяет оптимизировать доступ к разделяемым ресурсам, когда операция чтения выполняется гораздо чаще, чем операция записи.
  	- RLock() - мьютекс блокируется на чтение. Несколько горутин могут одновременно захватывать на чтение
  	- RUnlock() - освобождает блокировку для чтения
  	- Lock() - блокирует мьютекс на запись. При этом никакая другая горутина не может получить доступ ни для чтения, ни для записи, пока мьютекс не будет разблокирован.
  	- Unlock() - освобождает блокировку для записи и чтения

6. Что такое atomics, какие бывают и как и когда их лучше использовать?

Атомики - специальные низкоуровневые операции, которые позволяют работать с данными так, чтобы операции были "неразрывными". В контексте многопоточности это значит, что разные горутины не смогут «вмешаться» внутрь одной операции и получить неконсистентное состояние переменной. 
**Два важных свойства**:
- Атомарность - операция либо уже полностью совершена, либо ещё не началась (не бывает «полусовершённого» состояния);
- Видимость – результат атомарной операции сразу становится виден другим горутинам.

**Атомарные операции**
Атомики дают возможность в некоторых случаях обойтись без мьютексов и использовать вместо них набор низкоуровневых операций, работающих напрямую с объектами в памяти.
- Чтение (Read);
- Запись (Load);
- Атомарное увеличение (Add);
- Сравнить и заменить (Compare and Swap).
Их главная особенность в том, что они выполняются атомарно даже при параллельном доступе из нескольких горутин. За счёт этого часто удаётся реализовать быструю и простую синхронизацию, не прибегая к блокировкам, когда задача сводится к поддержке счётчиков или простых флагов.

**Когда лучше использовать?**
Лучше всего подойдет в высоконагруженных сценариях, чтобы не "долбиться" mutex. Также хорошо подойдет в низкоуровневых lock-free структурах. 

7. Что такое sync.Map?



8. Что такое lock-free структуры данных, и есть ли в Go такие?

Lock-free cтруктуры данных - структура данных, которая не опирается на блокировку. Реализуют конкурентный доступ с помощью атомарных операци (CAS - compare and swap). Обладают пониженной задержкой, избегают дедлоки и увеличивают производительность.

**Основные характеристики lock-free структур данных**
- В lock-free алгоритмах не используются мьютексы или другие примитивы, основанные на блокировках, что исключает ситуации взаимного блокирования (deadlock) и снижает накладные расходы, связанные с переключением контекста.
- Для изменения данных применяются атомарные примитивы (например, CAS, атомарное сложение или обмен). Эти операции выполняются неделимо, что позволяет нескольким горутинам одновременно пытаться обновить значение, при этом гарантируя корректное состояние.
- В lock-free алгоритмах гарантируется, что хотя бы одна операция завершится успешно, даже если конкуренция высока. Это отличается от wait-free алгоритмов, где гарантируется, что каждая операция завершится за конечное число шагов.
- В сценариях с высокой конкуренцией lock-free структуры могут работать быстрее, поскольку отсутствуют затратные операции захвата и освобождения блокировок.

  **Lock-Free в Go**
  В стандартной библиотеке Go нет готовых контейнеров, специально реализованных как lock-free. Вместо этого язык предоставляет пакет sync/atomic, который позволяет выполнять атомарные операции над переменными. Эти атомарные примитивы служат строительными блоками для реализации lock-free алгоритмов. Например, с помощью CAS можно создать lock-free счетчик или обновлять указатели на структуры данных без применения мьютексов.



9. Как можно обработать панику с помощью defer и recovery?

Recover — это встроенная функция, которая восстанавливает контроль над паникующей го-процедурой. Recover полезна только внутри отложенного вызова функции. Во время нормального выполнения, recover возвращает nil и не имеет других эффектов. Если же текущая го-процедура паникует, то вызов recover возвращает значение, которое было передано panic и восстанавливает нормальное выполнение.

```go
package main

import "fmt"

func main() {
    f()
    fmt.Println("Returned normally from f.")
}

func f() {
    defer func() {
        if r := recover(); r != nil {
            fmt.Println("Recovered in f", r)
        }
    }()
    fmt.Println("Calling g.")
    g(0)
    fmt.Println("Returned normally from g.")
}

func g(i int) {
    if i > 3 {
        fmt.Println("Panicking!")
        panic(fmt.Sprintf("%v", i))
    }
    defer fmt.Println("Defer in g", i)
    fmt.Println("Printing in g", i)
    g(i+1)
}
```

```
Calling g.
Printing in g 0
Printing in g 1
Printing in g 2
Printing in g 3
Panicking!
Defer in g 3
Defer in g 2
Defer in g 1
Defer in g 0
Recovered in f 4
Returned normally from f.
```


```go
package main

import "fmt"

func main() {
    // Вызываем функцию, в которой может произойти паника.
    safeFunction()
    fmt.Println("Программа продолжила выполнение")
}

func safeFunction() {
    // Отложенная функция для обработки паники.
    defer func() {
        if r := recover(); r != nil {
            // recover() поймал панику и вернул значение.
            fmt.Println("Обработана паника:", r)
        }
    }()

    fmt.Println("Начало выполнения функции safeFunction")
    // Здесь происходит паника, например:
    panic("Что-то пошло не так!")
    // Код ниже не выполнится, так как сработала паника.
    fmt.Println("Конец функции safeFunction")
}
```
Часто используется в http роутерах
- В серверах часто оборачивают каждый запрос в «промежуточный обработчик» (middleware), который восстанавливается (recover) при панике и отправляет корректный HTTP-ответ (например, 500 Internal Server Error) вместо краша всего сервера.
  

10. Что такое context в Go? Какие бывают context в Go? Когда их нужно использовать и зачем?

Context в Go - Интерфейс, который позволяет управлять жизненным циклом операций. Механизм для передачи сквозных данных, сигналов, отмены, работы с дедлайнами между горутинами при выполнении задачи.
- Содержит информацию об отмене и делайне
- Может хранить информацию через ключ-значение для передачи вспомогательной информации по цепочке вызовов
- Передаётся по цепочке

**Основные типы и способности создания контекста**
- context.Background() - базовый-корневой контекст, у которого нет ни дедлайна, ни отмены. Используется в основном потоке или при старте приложения
- context.TODO() - контекст, который используется как временная заглушка, когда еще не определились с конкретным контекстом. Он имеет такое же поведение, как и Background(), но сигнализирует, что требуется дальнейшая доработка.
- context.WithCancel(parent Context) - контекст, который можно отменить вручную с помощью функции CancelFunc
- context.WithTimeout(parent Context, Duration) - Создает контекст с дедлайном – если операция не завершается за указанное время, контекст автоматически отменяется.
- context.WithDeadline(parent Context, Time) - Позволяет задать конкретное время дедлайна, до которого операция должна завершиться. Функционально схож с WithTimeout, но принимает фиксированное время.
- contetx.WithValue(parent Context, key, val) - Создает контекст, ассоциированный с определённым значением. Обычно используется для передачи метаданных (например, идентификаторов, токенов) между горутинами.

Управление отменой операций:
В сетевых приложениях, например, HTTP-серверах, полезно передавать context, чтобы можно было отменить обработку запроса, если клиент прервал соединение или истёк таймаут. Это предотвращает расход ресурсов на выполнение бесполезных вычислений.

Задание дедлайнов:
При выполнении долгих операций или обращении к внешним сервисам можно задать дедлайн. Если операция не завершается вовремя, она автоматически отменяется, что помогает избежать зависания системы.

Передача сквозных данных:
Context позволяет удобно передавать информацию, связанную с конкретным запросом или операцией, не прибегая к глобальным переменным. Это делает код чище и способствует инкапсуляции.

Координация горутин:
В приложениях, где несколько горутин участвуют в выполнении одной задачи, context помогает централизованно контролировать их жизненный цикл – например, уведомить все горутины о необходимости завершения работы.

11. Что такое указатели? Как передаются параметры в функцию по указателю или по значению? Какие типы неявно передаются как указатель? Как передать по указателю?

Указатель - переменная, которая хранит в себе адрес на ячейку памяти другой переменной. То есть ссылку на местов памяти, где хранится значение.

**Передача параметров в функции**
В Go все параметры передаются по значениею, что означает при передаче переменной в функцию копируется её значение.
Есть два случая:
- Передача по значению (копирование): Если функция получает обычную переменную (например, число или структуру), она работает с копией этой переменной. Изменения внутри функции не влияют на оригинал.
- Передача указателя: Если мы передаем значение указателя в функцию, то он также копируется, но оба - и исходная переменная и параметр в функции(указатель) - указывают на одину и ту же ячейку в памяти. Таким образом, изменения через разыменование (оператор *) повлияют на оригинальное значение.

```go
package main

import "fmt"

func modifyByValue(x int) {
    x = 100  // Изменяется только копия, оригинальное значение не затронуто.
}

func modifyByPointer(x *int) {
    *x = 100  // Изменяется значение по адресу, оригинальная переменная изменяется.
}

func main() {
    a := 10
    b := 10

    modifyByValue(a)
    fmt.Println("После modifyByValue, a =", a)  // Выведет: 10

    modifyByPointer(&b)
    fmt.Println("После modifyByPointer, b =", b)  // Выведет: 100
}

```

В Go есть типы, которые являются ссылочными (reference types). Хотя их тоже передают по значению, значение содержит ссылку на данные, и поэтому они ведут себя подобно указателям:
- Slice - Структура среза содержит указатель на базовый массив, длину и вместимость. При передаче среза копируется эта структура, но базовый массив остается общим.
- Maps - Карта представляет собой ссылочный тип, поэтому при передаче карты функция получает копию ссылки на внутреннюю структуру данных, что позволяет изменять содержимое карты.
- Channels - Каналы тоже являются ссылочными типами, и их передача обеспечивает доступ к одному и тому же каналу.
- Func - Функциональные значения, как и указатели, содержат ссылку на реализацию функции.

Эти типы технически передаются по значению, копия содержит внутренний указатель на данные, что позволяет работать с одними и теми же данными в разных частях программы.

12. Что такое пакеты (package) в Go? Как их создавать и импортировать?

Пакет (package) в Go – это единица организации кода, которая позволяет группировать связанные функции, типы, переменные и константы в логические блоки. Пакеты способствуют повторному использованию кода, улучшению его читаемости и облегчению управления зависимостями в проекте.

Создаем пакет - package. Импортируем - import 

**Функция пакетов**
- Организация кода: Пакеты помогают структурировать проект, разделяя функциональность на логические части (например, работа с базой данных, утилиты для работы с данными, логирование).
- Повторное использование: Один и тот же пакет можно использовать в нескольких проектах, если вынести его в отдельный модуль.
- Инкапсуляция: Пакеты позволяют скрыть реализацию (неэкспортируемые имена, начинающиеся со строчной буквы) и предоставить только публичный интерфейс (экспортируемые имена, начинающиеся с заглавной буквы).

13. Можно ли реализовать sync.Mutex и sync.WaitGroup на каналах? Как?
