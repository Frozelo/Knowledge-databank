## Hot Questions

> [!NOTE] Пометка
> Самые ходовые вопросы, которые часто мелькают на собеседованиях

### Arrays and Slices

1. Что такое слайс (slice) и массив (array)? Чем отличается массив от слайса?
	В Go **массивы** и срезы представляют собой структуры данных, состоящие из упорядоченных последовательностей элементов. Эти наборы данных очень удобно использовать, когда вам требуется работать с большим количеством связанных значений. Массив в Go представляет собой структуру данных, состоящую из упорядоченной последовательности элементов, емкость которой определяется в момент создания. После определения размера массива его нельзя изменить.
	
	Срез — это версия массива с переменной длиной, дающая разработчикам дополнительную гибкость использования этих структур данных. 
	Срезы — это то, что обычно называют массивами в других языках. Срез — это тип данных Go, представляющий собой мутируемую или изменяемую упорядоченную последовательность элементов. Поскольку размер срезов не постоянный, а переменный, его использование сопряжено с дополнительной гибкостью. При работе с наборами данных, которые в будущем могут увеличиваться или уменьшаться, использование среза обеспечит отсутствие ошибок при попытке изменения размера набора. В большинстве случаев возможность изменения стоит издержек перераспределения памяти, которое иногда требуется для срезов, в отличие от массивов.

```go
// Создадим срез, содержащий элементы строкового типа данных:
seaCreatures := []string{"shark", "cuttlefish", "squid", "mantis shrimp", "anemone"} // len: 5, cap: 5

// Если вы хотите создать срез определенной длины без заполнения элементов коллекции, 
// вы можете использовать встроенную функцию make()
oceans := make([]string, 3) // output: [ "" "" "" ], len: 3, cap: 3

// Если вы хотите заранее выделить определенный объем памяти, вы можете использовать в команде make() третий аргумент:
oceans := make([]string, 3, 5) // output: [ "" "" "" ], len: 3, cap: 5
```

2. Как устроен слайс в Go? Как устроен массив в Go?
Слайс под капотом - структура с указателем на адрес базового массива и также две переменные: len и cap. 
   Len - Длина слайса - количество элементов, которое находится внутри слайса.
   Cap - Ёмкость слайса - количество элементов, которые мы можем поместить внутрь слайса сверх len без его дальнейшего расширения. 
```go
   type slice struct {
	   array unsafe.Pointer
	   len   int
	   cap int
   }
```
   Массив - последовательно выделенная область памяти. Частью массива является его неизменяемая длина. 

3. Как можно создать слайс? Что такое zero-value и какое оно у слайса?
Основные виды объявления слайса:
```go
   var slice []int             //declare nil slice len - 0, cap - 0
   var slice = []int{1, 2, 3}  //init slice len - 3, cap - 3
   slice := []int{1, 2, 3}     //init slice len - 3, cap - 3
   slice := make([]int, 0, 3)  //init слайс через make len - 0, cap - 10
   slice := make([]int, 3)     //init слайс через make len - 3, cap - 3 
```
  Zero-value для слайса - это nil, а len и cap равны нулю, так как "под ним" нет инициализированного массива:
```go
var a []int

fmt.Prinln((a == nil, len(a), cap(a)) // output: true 0 0
a = append(a, 1)
fmt.Println(a == nil, len(a), cap(a)) // output: false 1 1
```

4. Что такое nil слайс и чем отличается? Можно ли добавлять элементы в nil слайс?
Все основные операции, совершаемые над обычным (инициализированным) слайсом применимы и к nil слайсам
```go
var slice []int

fmt.Println(len(slice), cap(slice)) //output 0 0

slice = append(slice, 10)

fmt.Println(slice, len(slice), cap(slice)) // output [ 10 ] 1 1
```
   
5. Как проверить слайс на пустоту?
Проверить его длину на ноль
```go
var a []int

// не правильно
fmt.Println(a == nil) // true

// а если так
a := []int{}
fmt.Println(a == nil) // false

// поэтому правильно так
fmt.Println(len(a) == 0) // true
```

6. Как работает базовая функция append для слайсов? Можно ли применить к массивам? Напишите свою функцию append.
Функция принимает на вход слайс и переменное количество элементов для добавления в слайс. Append расширяет слайс за пределы его len, возвращая при этом новый слайс.
   
   Если количество элементов, которые мы добавляем в слайс, не будет превышать cap, вернется новый слайс, который ссылается на тот же базовый массив, что и предыдущий слайс. Если количество добавляемых элементов превысит cap, то вернется новый слайс, базовым для которого будет новый массив.
   
```go
// создаем слайс с capacity равным 3 и длиной 0
slice := make([]int, 0, 3) 	// len: 0, cap: 3
	
// далее заполняем слайс тремя элементами
slice = append(slice, 1) 	// len: 1, cap: 3
slice = append(slice, 2, 3) 	// len: 3, cap: 3

// получаем ожидаемый результат
fmt.Println(slice) // output [ 1, 2, 3 ]

// окей, теперь попробуем присводить слайс другому слайсу
// помним то, что слайс является структурой из трех элементов len, cap и указателем н первый элемент массива
// поэтому в sliceCopy мы получаем скопированные значение len и cap, а так же указатель на тот же массив, что и у переменной slice
sliceCopy := slice

// пробуем менять первый элемент в новом слайсе
sliceCopy[1] = 10
	
// убеждаемся, что в обоих слайсах изменились значения, все из-за базового массива
fmt.Println(slice, sliceCopy) // output: slice: [ 1, 10, 3 ] sliceCopy: [ 1, 10, 3 ]

// хорошо, теперь пробуем добавить новый элемент в первый слайс
slice = append(slice, 4)
// тут у нас функция append "видит", что мест больше нет и увеличивает cap в двое, увеличивает len на один
// и создает новый базовый массив с местимостью в 6 элементов, что и видим на печати
fmt.Println(slice) // output: [ 1, 10, 3, 4] len: 4, cap: 6
// но что случилось тут? ничего, просто ничего, теперь первая переменная смотрит на другой базовый массив и они больше никак не связаны
fmt.Println(sliceCopy) // output: [ 1, 2, 3 ] len: 3, cap: 3

// точно не связаны? ну давай убедимся! пробуем менять значения первых элементов в обоих слайсах
sliceCopy[0] = 50
slice[0] = 80

fmt.Println(slice, sliceCopy) // output: slice: [ 80, 10, 3, 4 ] sliceCopy: [ 50, 10, 3 ]
```

   С масивами функцию append использовать нельзя иначе получим ошибку: `first argument to append must be slice; have T`
   Реализация простой добавки в слайс
```go
func main() {
	fmt.Println(Append([]int{1, 2, 3}, 4))
}

func Append[T any](dst []T, el T) []T {
	var res []T

	resLen := len(dst) + 1
	if resLen <= cap(dst) {
		res = dst[:resLen]
	} else {
		resCap := resLen
		if resCap < 2*len(dst) {
			resCap = 2 * len(dst)
		}

		res = make([]T, resLen, resCap)
		copy(res, dst)
	}

	res[len(dst)] = el
	return res
}
   
```
   
7. Как можно добавить элементы в слайс? Что будет если элемент не вмещается в размер слайса?
   Использование append
```go
slice := make([]int, 0, 10) // len: 0, cap: 10
for i := 0; i < 10; i++ {
	slice = append(slice, i*2)
}
   
```
   
   Индексы
```go
slice := make([]int, 10) // len: 10, cap: 10
for i := 0; i < 10; i++ {
	slice[i] = i*2
}
```

   Проблема в том, что во втором случае если количество элементов, которые мы хотим добавить в слайс превысит емкость исходного слайса, тогда мы получим панику: `panic: runtime error: index out of range [10] with length 10`
```go
slice := make([]int, 10) // len: 10, cap: 10
for i := 0; i <= 10; i++ {
	slice[i] = i * 2
}
```
   При append произойдет аллокакция памяти для базового массива, слайс расширится. 
   
8. Как можно скопировать слайс? Что такое функция copy? Как добиться аналогичного поведения copy с помощью append?
Работаем с функцией copy сигнатура
```go
func copy(dst, src []Type) int
```

9. Как можно слить два слайса?
Объединение фрагментов в Go легко достигается с помощью той же встроенной функции append. Как мы помним он принимает срез (s1) в качестве первого аргумента и все элементы из второго среза (s2) в качестве второго. Возвращается обновленный срез со всеми элементами из s1 и, который может быть присвоен другой переменной.

```go
s1 := []int{1, 2, 3}
s2 := []int{4, 5, 6}

s3 := append(s1, s2...)
fmt.Println(s3) // output: [ 1, 2, 3, 4, 5, 6 ]
```

10. Как можно нарезать слайс? Какие есть нюансы, подводные камни?
Можно сделать подсалайс из слайса или массива:
```go
slice := []int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}
subSlice := slice[3:8] // [ 4, 5, 6, 7, 8 ]
```

Нюанс в том, что если мы изменим или добавим значение в сабслайс, то это значение изменится/добавится и в базовый слайс

```go
subSlice[0] = 101

fmt.Println(slice) // [1 2 3 101 5 6 7 8 9 10]
fmt.Println(subSlice) // [101 5 6 7 8]
```

Видим, что в базовом слайсе тоже поменялись значения, а все потому, что у под слайса все тот же базовый массив, а для подслайса нулевой элемент это элемент под индексом 3 в базовом. Примерно такое же поведение наблюдается у функции append, если его применить к под слайсу базового слайса:
```go
slice := make([]int, 10, 25)
subSlice := slice[3:5] // [ 0, 0]

fmt.Println(len(slice), cap(slice)) // 10 25
fmt.Println(len(subSlice), cap(subSlice)) // 2 22

subSlice = append(subSlice, 11)

fmt.Println(slice) // [0 0 0 0 0 11 0 0 0 0]
fmt.Println(subSlice) // [0 0 11]
```
причина данного поведения в том, что у обоих слайсов один базовый массив, а так же у под слайса своя "копия" слайса с полями len и cap и когда мы пытаемся добавить в дочерний слайс элемент, при условии, что в родитльском хватает емкости, мы просто перезаписываем значение в базовом массива.

---
### Maps

1. Что такое Map? Как устроен в Go? Желательно приблизительно понимать структуру (type hmap struct) и его поля
2. Что такое хеш-функция?
3. Почему нельзя брать ссылку на значение, хранящееся по ключу в map?
4. Что такое эвакуация, и в каком случае она будет происходить?
5. Какие есть особенности синтаксиса получения и записи значений в map?
6. Как происходит поиск по ключу в map?
7. Каков порядок перебора map?
8. Что будет происходить при конкуррентной записи в map? Как можно решить эту проблему?
9. Как защититься от ошибки во время конкурентной записи в map?
---
### Channels

1. Что такое канал? Чем отличается буферизированный канал от небуферизированного?
2. Как создать канал? Как закрыть канал?
3. Как читать из канала и писать в канал?
4. Зачем нужны в целом каналы?
5. Что будет, если читать из закрытого канала?
6. Что будет, если писать в закрытый канал?
7. Что будет если закрыть закрытый канал?
8. Что такое nil канал и что будет если писать и читать от туда?
---
### Strings

1. Что из себя представляет тип данных string в языке Golang? Можно ли изменить определенный символ в строке? Что происходит при склеивании строк?
2. Как можно оперировать строками?
3. Что будет если сложить строки?
4. Как определить количество символов для строки?
5. Какие есть нюансы при итерации по строке?
6. Как эффективно склеивать строки (конкатенация строк)?
---
### Types

1. Какие бывают типы в Go? Целочисленные, дробные, комплексные, структуы, интерфесы, время и дополнить.
2. Отличие uint от int?
3. Что такое обычный int и какие есть нюансы его реализации?
4. Как преобразовать строку в int и наоборот? Можно ли сделать int(string) и string(int) соответственно?
5. Сколько в памяти занимают реализации int32 и int64?
6. Какие предельные значения int32 и int64?
7. Какой результат получим если разделить int на 0 и float на 0?
8. Что такое константы и можно ли их изменять?
9. Что такое iota?
10. Что такое структура (stuct) в Go? Зачем они нужны?
11. Что такое метод? Как они выглядят?
12. Как осуществляется наследование в Go?
13. Что такое тип rune? Зачем их использовать?
14. Что такое тип byte?
15. Что такое goto?
16. Какие циклы есть в Go?
---
### Interfaces

1. Что такое интерфейсы в Go? Чем отличается от интерфейсов в дпугих языказ, например, Java, PHP. Что такое утиная типизация?
2. Внутренее устройство интерфейса, какое оно (структура iface, itab)?
3. Сделать интерфейс для вычисления площади круга и квадрата, реализовать их в структурах cicle и square.
4. Что такое пустой интерфейс?
5. Что такое nil интерфейс?
6. Что такое type switch?
7. Как определить тип интерфейса?
8. Как преобразовать интерфейс к другому типу?
9. Где следует поместить описание интерфейса: в пакете с реализацией или в пакете, где этот интерфейс используется? Почему?
---
### Runtime Go

1. Что такое runtime (планировщик sheduler)? Как он устроен в Go?
2. Что такое Gorutine (горутина)?
3. В чем отличие горутины от потока?
4. Как устроены горутины, сколько памяти они занимают в стеке?
5. Кто управляет горутинами? Какой тип многозадачности используется в Go и какой был до версии Go 1.15?
6. Что такое GC (garbadge collector/сборщик мусора)?
7. Как работает сборщик мусора в Go?
8. Как проверить тип переменной в среде выполнения?
---
### Testing

1. Что такое runtime (планировщик sheduler)? Как он устроен в Go?
2. Что такое Gorutine (горутина)?
3. В чем отличие горутины от потока?
4. Как устроены горутины, сколько памяти они занимают в стеке?
5. Кто управляет горутинами? Какой тип многозадачности используется в Go и какой был до версии Go 1.15?
6. Что такое GC (garbadge collector/сборщик мусора)?
7. Как работает сборщик мусора в Go?
8. Как проверить тип переменной в среде выполнения?
---
### CI/CD

0. Что такое CI/CD?
1. Что такое линтеры (linters) зачем они нужны и как их использовать?
2. Как можно измерить использование памяти в Go? Что такое pprof?
3. Что такое Prometheus и Grafana? Зачем они нужны?
---
### Other

1. Зачем используется ключевое слово defer в Go?
2. Каков порядок возврата при использовании несколько функций с defer в рамках одной внешней функции?
3. Как передаются значения в функции, перед которыми указано ключевое слово defer? Пример:

```go
func main() {
	nums := 1 << 5 // 32

	defer fmt.Println(nums) // тут как?

	nums = nums >> 1 //16

	fmt.Println("done")
}
```

4. Какие бывают способоы синхронизации данных в Go? (про каналы тоже не забываем)
5. Что такое mutex, какие они бывают и как их использовать?
6. Что такое atomics, какие бывают и как и когда их лучше использовать?
7. Что такое sync.Map?
8. Что такое lock-free структуры данных, и есть ли в Go такие?
9. Как можно обработать панику с помощью defer и recovery?
10. Что такое context в Go? Какие бывают context в Go? Когда их нужно использовать и зачем?
11. Что такое указатели? Как передаются параметры в функцию по указателю или по значению? Какие типы неявно передаются как указатель? Как передать по указателю?
12. Что такое пакеты (package) в Go? Как их создавать и импортировать?
13. Можно ли реализовать sync.Mutex и sync.WaitGroup на каналах? Как?
