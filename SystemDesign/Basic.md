
## Архитектуры Информационных систем

- File-Server - Извлекает данные из файла или базы данных и передаёт клиенту для дальнейшей обработки. Устаревший подход. Так как он непрактичен и небезопасен. 
- Client-Server - Извлекает данные из файла или базы данных **обрабатывает** и только потом передаёт данные клиенту. 
- P2P (Peer to peer) - Нет центра сервера. Все узлы исполняются одинаково. Каждый узел является и клиентом и сервером. Например торрент, блокчейн. 


### Критерии системы
- Надёжность - метрики,  «количество 9» uptime 
- Отказоустойчивость
- Масшатабируемость - предусмотрены разумные способы решения при росте проблем
	- Вертикальный - больше железа (просто и быстро)
	- Горизонтальный - «размазываем» на инстансы, докупаем новый сервис. 
- State type
	- Stateless - Не хранят состояние (запроса). То есть каждый запрос обрабатывается как новый
	- Statefull - Хранит состояние
- Производительность (Latency, response time)
![[Снимок экрана 2024-10-30 в 01.12.35.png]]
- Безопасность


### Свойства информационной системы

**HighLoad**

**Data-intensive** (I/O Bound)
- Нужно сохранять большие данные
- Запоминать операции ресурсоёмких операций
- Нужно предоставлять пользователям искать и фильтровать данные

**Compute-intensive** (CPU Bound)
- Подсчёт


## Архитектура Backend

**Монолит** **VS** **Микросервисы**

**Микросервисы**
- Не про размер, про зону отвественности
- Самодостаточны - горизонтальное масштабирование
- Использование разных технологий для разных задач
- Распределенная кодовая база

*Плюсы*
- Независимая разработка
- Независимая масштабируемость
- Независимая деградация

*Минусы*
- «Зоопарк технологий»
- Сетевой вызов
- Транзакции
- Контекст запроса
- Сложное тестирование всей системы
![[Снимок экрана 2024-10-30 в 11.33.20.png]]

## Load Balancer (LB)

Распределяем балансировку между интсансами

**Способы балансировки**
1. ![[Снимок экрана 2024-10-30 в 11.40.11.png]]
2. ![[Снимок экрана 2024-10-30 в 11.41.00.png]] Используем Балансировщик нагрузки, который *как-то* это всё распределяет

**Алгоритмы балансировки нагрузки**
- Random ![[Снимок экрана 2024-10-30 в 11.42.58.png]]
- Round Robin - Каждому своё, распределение по кругу. Веса не учитываем 80%-90%![[Снимок экрана 2024-10-30 в 11.44.12.png]]
- WRR (Weight Round Robin)![[Снимок экрана 2024-10-30 в 11.45.26.png]]
- Sticky Sessions - В наших инстансах хранится кеш конкретной сущности, тогда лучше эту сущность отправлять на нужный инстанс ![[Снимок экрана 2024-10-30 в 11.46.54.png]] То есть если посмотреть - пользователь постоянно ходит на свой инстанс.  Как правило мы хешируем данные о пользователе, берём остаток от деления на количество узлов и получаем нужный нам инстанс.
- DNS балансировщик ![[Снимок экрана 2024-10-30 в 11.59.20.png]]
- Geo DNS - стараемся уменьшить latency ![[Снимок экрана 2024-10-30 в 12.01.13.png]]

## Проксирование

Мы общаемся с сервером не напрямую, а через какую-то промежуточную точку - Proxy
Выполняем задачи до входа на сервис. 
- Защита
- Кэширование
- Ограничение Трафика
- Авторизация
- Анонимность
- Сжатие данных

## Кеширование

Храним данные в «горячей» точке - оперативной памяти. 

- Сокращение response time
- Снижение нагрузки на сервисы
- Переиспользование ранее полученных данных

Горячий ключ - ключ, на который приходится множество запросов (Криро SUII)
Прогрев кеша - наполнение
Инвалидация кеша - удаление в нужные моменты [[ACID]]

**Какие данные кешируем**?
- Меняются нечасто
- Меняются редко

**Кеширование ошибок**
Кешируем ошибки и тогда последующие запросы не будут обращаться к источнику информации. 

**По хорошему нужно уметь держать нагрузку без кеша**
Задача кеша - ускорить ответ, а не снизить нагрузку на сервис


**Виды кеширование**

- ![[Снимок экрана 2024-10-30 в 23.34.26.png]] Кеш на сервисе - Statefull
  *Плюсы*: Высокая скорость, Отсутствие внешних запросов
  *Минусы*: Прогрев кеша после падения
- ![[Снимок экрана 2024-10-30 в 23.37.53.png]] Отдельная сущность для кеша
 
