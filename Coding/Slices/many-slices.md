```go
package main

import (
	"fmt"
)

func main() {
	a := []int{1, 2, 3}
	b := a
	b = append(b, 4)
	c := b
	b[0] = 0
	e := append(c, 5)
	b[2] = 7

	fmt.Println(a, b, c, e) // что отобразится после вызова?
}
```

Вывыод - ([1 2 3] [0 2 7 4] [0 2 7 4] [0 2 7 4 5])

Создаётся слайс a длины 3 и ёмкости 3, хранящий элементы [1,2,3].

b указывает на тот же бэкинг-массив, что и a.

Сейчас a и b оба «видят» [1,2,3], len=3, cap=3.

У b len(cap)=3, поэтому при append выделяется новый массив (обычно с удвоенной ёмкостью, т.е. cap=6), в который копируются [1,2,3], а затем добавляется 4.

b теперь указывает на новый массив [1,2,3,4] (len=4, cap=6),

в то время как a остаётся указывать на старый массив [1,2,3] (len=3, cap=3).

c теперь тоже смотрит на тот же новый массив, что и b.

И b, и c «видят» [1,2,3,4] (len=4, cap=6).

Изменяет первый элемент в бэкинг-массиве b/c.

Новый массив становится [0,2,3,4].

b и c: [0,2,3,4]; a остаётся [1,2,3].

У c сейчас len=4, cap=6, поэтому append записывает 5 в пятый слот того же массива.

Массив становится [0,2,3,4,5, …].

e — слайс длины 5, указывающий на первые пять элементов этого массива: [0,2,3,4,5].

b и c по-прежнему имеют len=4 и «видят» первые четыре элемента: [0,2,3,4].

Меняет третий элемент в общем бэкинг-массиве (для b, c и e).

После этого массив выглядит так: [0,2,7,4,5,…].


**То есть**
a всё ещё ссылается на старый массив

b и c — на новый, первые **четыре элемента**

e — на тот же новый, первые **пять элементов**
