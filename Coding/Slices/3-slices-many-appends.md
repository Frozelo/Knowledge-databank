```go
package main

import (
	"fmt"
)

func main() {
	x := []int{}
	x = append(x, 0)
	x = append(x, 1)
	x = append(x, 2)
	y := append(x, 3)
	z := append(x, 4)
	fmt.Println(y, z) // что отобразится после вызова?
}
```

Вывод - ([0, 1, 2, 3, 4], [0, 1, 2, 3, 4])

x = append(x, 0) // x → [0], len(x) = 1, cap(x)=1

x = append(x, 1) // x → [0 1], len(x) = 2, cap(x)=2

x = append(x, 2) // x → [0 1 2], len(x) = 3, cap(x)=4

После трёх вызовов append слайс x содержит [0, 1, 2] и при этом его ёмкость выросла до 4. Все эти элементы хранятся в одном и том же подлежащем массиве.
y := append(x, 3)

Поскольку len(x)=3 и cap(x)=4, этот append помещает 3 в четвёртую ячейку уже существующего массива.

— y указывает на слайс длины 4: [0 1 2 3] (из того же бэкинг-массива).

z := append(x, 4)

Здесь мы снова делаем append к исходному x (а не к y!), и т.к. у x всё ещё len=3, cap=4, новый элемент записывается в ту же самую четвёртую ячейку бэкинг-массива. Он перезаписывает значение 3 на 4.

Оба слайса y и z ссылаются на один и тот же массив, а последняя запись была 4. Поэтому и y, и z покажут одно и то же:
