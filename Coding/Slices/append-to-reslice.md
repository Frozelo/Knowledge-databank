```go
package main

import (
	"fmt"
)

func testSlices2() {
	a := []byte{'a', 'b', 'c'}
	b := append(a[1:2], 'd')
	b[0] = 'z'

	fmt.Printf("%s\n", a) // что отобразится после вызова?
}

func main() {
	testSlices2()
}
```

Вывод - ([a, z, d])

Вся основаня суть - в реслайсле a[1:2]

a[1:2] даёт слайс из одного элемента: ['b'], с len=1, cap= originalCap - 1 = 3-1 = 2.

При append к этому слайсу (len=1, cap=2) есть место для ещё одного элемента, поэтому не выделяется новый массив, мы пишем прямо в старый:

append кладёт 'd' в ячейку с индексом 1 внутри слайса b → это соответствует второй позиции в подлежащем массиве, т.е. a[2].

После этого подлежащий массив превращается из ['a','b','c'] в ['a','b','d'].

Слайс b теперь имеет len=2 и видит ['b','d'].

b[0] = 'z' - Это меняет первый элемент слайса b, то есть элемент b в подлежащем массиве: подлежащий массив становится ['a','z','d'].

Так как и a и b всё ещё ссылаются на один и тот же массив, то к моменту Подлежащий массив = ['a','z','d']. **Слайс a развёрнут по всему массиву** и содержит ['a','z','d']
